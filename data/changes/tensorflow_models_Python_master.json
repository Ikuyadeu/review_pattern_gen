[
 {
  "sha": "9e680d187113aa8f87c7b7a33ff9573df02895d0",
  "author": "Yuki Ueda",
  "created_at": "2019-07-31 15:07:43",
  "condition": [
   "\"gru\": tf.contrib.rnn.GRUCell,"
  ],
  "consequent": [
   "\"gru\": tf.nn.rnn_cell.GRUCell,"
  ]
 },
 {
  "sha": "9e680d187113aa8f87c7b7a33ff9573df02895d0",
  "author": "Yuki Ueda",
  "created_at": "2019-07-31 15:07:43",
  "condition": [
   "\"rnn\": tf.contrib.rnn.RNNCell,"
  ],
  "consequent": [
   "\"rnn\": tf.nn.rnn_cell.RNNCell,"
  ]
 },
 {
  "sha": "9e680d187113aa8f87c7b7a33ff9573df02895d0",
  "author": "Yuki Ueda",
  "created_at": "2019-07-31 15:07:43",
  "condition": [
   "\"lstm\": tf.contrib.rnn.BasicLSTMCell,"
  ],
  "consequent": [
   "\"lstm\": tf.nn.rnn_cell.BasicLSTMCell,"
  ]
 },
 {
  "sha": "c6183922cc5ff35ab2cbd12b9b6704e4792264da",
  "author": "Mark Daoust",
  "created_at": "2019-07-31 07:21:39",
  "condition": [
   "return dataset"
  ],
  "consequent": [
   "return dataset.make_one_shot_iterator().get_next()"
  ]
 },
 {
  "sha": "c45213c91d39c57b856b918559c4d73398eb8652",
  "author": "jianchao-li",
  "created_at": "2018-12-17 12:41:30",
  "condition": [
   "if StrictVersion(tf.__version__) < StrictVersion(\"1.1.0\") and FLAGS.num_gpus > 1:"
  ],
  "consequent": [
   "if tf.__version__ < \"1.1.0\" and FLAGS.num_gpus > 1:"
  ]
 },
 {
  "sha": "c45213c91d39c57b856b918559c4d73398eb8652",
  "author": "jianchao-li",
  "created_at": "2018-12-17 12:41:30",
  "condition": [
   "if FLAGS.num_gpus != 1 or StrictVersion(tf.__version__) < StrictVersion(\"1.3.0\") :"
  ],
  "consequent": [
   "if FLAGS.num_gpus != 1 or tf.__version__ < \"1.3.0\" :"
  ]
 },
 {
  "sha": "c45213c91d39c57b856b918559c4d73398eb8652",
  "author": "jianchao-li",
  "created_at": "2018-12-17 12:41:30",
  "condition": [
   "assert StrictVersion(\"1.4\") <= StrictVersion(tf_version), \"TensorFlow r1.4 or later is needed\""
  ],
  "consequent": [
   "assert \"1.4\" <= tf_version, \"TensorFlow r1.4 or later is needed\""
  ]
 },
 {
  "sha": "2533c6978e9b57d8d8dfd6f11bcedcdd73d2f15d",
  "author": "Toby Boyd",
  "created_at": "2019-07-25 09:45:33",
  "condition": [
   "self._run_and_report_benchmark(hr_at_10_min=0.61, hr_at_10_max=0.65)"
  ],
  "consequent": [
   "self._run_and_report_benchmark(hr_at_10_min=0.61)"
  ]
 },
 {
  "sha": "1c509f1951deee7bf61a4fffc6b91a6423365ab5",
  "author": "Toby Boyd",
  "created_at": "2019-07-25 09:45:18",
  "condition": [
   "def benchmark_1_gpu_no_ds(self):"
  ],
  "consequent": [
   "def benchmark_1_gpu_no_ds_run_eagerly(self):"
  ]
 },
 {
  "sha": "9fb1a1b671969af6fb7029bb446835394ccdc4a9",
  "author": "Soroush Radpour",
  "created_at": "2019-07-25 07:30:28",
  "condition": [
   "run(flags.FLAGS)"
  ],
  "consequent": [
   "return run(flags.FLAGS)"
  ]
 },
 {
  "sha": "c612d8c7c58cdfdd2e2e27bbf831a1154b5ca095",
  "author": "Toby Boyd",
  "created_at": "2019-07-25 01:34:33",
  "condition": [
   "hr_at_10_max=hr_at_10_max)"
  ],
  "consequent": [
   "top_1_max=hr_at_10_max)"
  ]
 },
 {
  "sha": "c612d8c7c58cdfdd2e2e27bbf831a1154b5ca095",
  "author": "Toby Boyd",
  "created_at": "2019-07-25 01:34:33",
  "condition": [
   "hr_at_10_min=hr_at_10_min,"
  ],
  "consequent": [
   "top_1_min=hr_at_10_min,"
  ]
 },
 {
  "sha": "c612d8c7c58cdfdd2e2e27bbf831a1154b5ca095",
  "author": "Toby Boyd",
  "created_at": "2019-07-25 01:34:33",
  "condition": [
   "self._run_and_report_benchmark(hr_at_10_min=0.61)"
  ],
  "consequent": [
   "super(NCFKerasAccuracy, self)._run_and_report_benchmark(hr_at_10_min=0.61)"
  ]
 },
 {
  "sha": "d09994b26ac8592765be45dc8a8444ead55eb32b",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:21",
  "condition": [
   "def benchmark_1_gpu_no_dist_strat_force_v2(self):"
  ],
  "consequent": [
   "def benchmark_1_gpu_force_dist_strat(self):"
  ]
 },
 {
  "sha": "d09994b26ac8592765be45dc8a8444ead55eb32b",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:21",
  "condition": [
   "\"\"\"No dist strat but forced v2 execution tf.compile path.\"\"\""
  ],
  "consequent": [
   "\"\"\"No dist strat but forced ds tf.compile path.\"\"\""
  ]
 },
 {
  "sha": "d09994b26ac8592765be45dc8a8444ead55eb32b",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:21",
  "condition": [
   "\"\"\"Forced v2 execution in tf.compile path and force eager.\"\"\""
  ],
  "consequent": [
   "\"\"\"No dist strat but forced ds tf.compile path and force eager.\"\"\""
  ]
 },
 {
  "sha": "d09994b26ac8592765be45dc8a8444ead55eb32b",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:21",
  "condition": [
   "FLAGS.force_v2_in_keras_compile = True"
  ],
  "consequent": [
   "FLAGS.force_run_distributed = True"
  ]
 },
 {
  "sha": "d09994b26ac8592765be45dc8a8444ead55eb32b",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:21",
  "condition": [
   "def benchmark_1_gpu_no_dist_strat_force_v2_run_eagerly(self):"
  ],
  "consequent": [
   "def benchmark_1_gpu_force_dist_strat_run_eagerly(self):"
  ]
 },
 {
  "sha": "829190e67385b93d462440fd8ca133890d8f6284",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:06",
  "condition": [
   "def _run_and_report_benchmark(self, hr_at_10_min=0, hr_at_10_max=0):"
  ],
  "consequent": [
   "def _run_and_report_benchmark(self):"
  ]
 },
 {
  "sha": "829190e67385b93d462440fd8ca133890d8f6284",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:06",
  "condition": [
   "   Note: MLPerf like tests are not tuned to hit a specific hr@10 value, but",
   "   we want it recorded.",
   "   \"\"\"",
   "   super(NCFKerasAccuracy, self)._run_and_report_benchmark(hr_at_10_min=0.61)",
   " def _run_and_report_benchmark(self, hr_at_10_min=0.630, hr_at_10_max=0.640):",
   "   \"\"\"Run test and report results.",
   "   Note: Target is 0.635, but some runs are below that level. Until we have"
  ],
  "consequent": [
   "# Target is 0.635, but some runs are below that level. Until we have"
  ]
 },
 {
  "sha": "829190e67385b93d462440fd8ca133890d8f6284",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:06",
  "condition": [
   "multi-run tests, we have to accept a lower target."
  ],
  "consequent": [
   "# multi-run tests, we have to accept a lower target.",
   "metrics.append({'name': 'hr_at_10',",
   "                'value': stats['eval_hit_rate'],",
   "                'min_value': 0.630,",
   "                'max_value': 0.640})"
  ]
 },
 {
  "sha": "829190e67385b93d462440fd8ca133890d8f6284",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:06",
  "condition": [
   "def _run_and_report_benchmark_mlperf_like(self):",
   "  \"\"\"Run test and report results."
  ],
  "consequent": [
   "def _extract_benchmark_report_extras(self, stats):",
   "  metrics = []",
   "  metrics.append({'name': 'exp_per_second',",
   "                  'value': stats['avg_exp_per_second']})"
  ]
 },
 {
  "sha": "829190e67385b93d462440fd8ca133890d8f6284",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:06",
  "condition": [
   "Args:",
   "  hr_at_10_min: Minimum acceptable hr@10 value.",
   "  hr_at_10_max: Maximum acceptable hr@10 value.",
   "\"\"\"",
   "super(NCFKerasAccuracy, self)._run_and_report_benchmark(",
   "    top_1_min=hr_at_10_min,",
   "    top_1_max=hr_at_10_max)"
  ],
  "consequent": [
   "   metrics.append({'name': 'train_loss',",
   "                   'value': stats['loss']})",
   "   return metrics"
  ]
 },
 {
  "sha": "829190e67385b93d462440fd8ca133890d8f6284",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:06",
  "condition": [
   "   metrics = []",
   "   metrics.append({'name': 'exp_per_second',",
   "                   'value': stats['avg_exp_per_second']})",
   "   if hr_at_10_min > 0:",
   "     metrics.append({'name': 'hr_at_10',",
   "                     'value': stats['eval_hit_rate'],",
   "                     'min_value': hr_at_10_min,",
   "                     'max_value': hr_at_10_max})",
   "     metrics.append({'name': 'train_loss',",
   "                     'value': stats['loss']})"
  ],
  "consequent": [
   "metrics = self._extract_benchmark_report_extras(stats)"
  ]
 },
 {
  "sha": "829190e67385b93d462440fd8ca133890d8f6284",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 14:06:06",
  "condition": [
   "self._run_and_report_benchmark_mlperf_like()"
  ],
  "consequent": [
   "self._run_and_report_benchmark()"
  ]
 },
 {
  "sha": "296d0d3fc8efd5f165c10a71a9e1235b5889bb90",
  "author": "guptapriya",
  "created_at": "2019-07-19 14:29:43",
  "condition": [
   "def test_train_no_dist_strat(self):"
  ],
  "consequent": [
   "def test_train(self):"
  ]
 },
 {
  "sha": "ffbada72cc34f2006be511974fd27b4cf8c0280e",
  "author": "guptapriya",
  "created_at": "2019-07-19 14:26:58",
  "condition": [
   "label_dtype=tf.int64,"
  ],
  "consequent": [
   "label_dtype=tf.int32,"
  ]
 },
 {
  "sha": "ffbada72cc34f2006be511974fd27b4cf8c0280e",
  "author": "guptapriya",
  "created_at": "2019-07-19 14:26:58",
  "condition": [
   "input_dtype=tf.int64,"
  ],
  "consequent": [
   "input_dtype=tf.int32,"
  ]
 },
 {
  "sha": "13cc0f70e9951d6e64b5c37877ccf3aaaae44032",
  "author": "guptapriya",
  "created_at": "2019-07-19 14:26:04",
  "condition": [
   "model = tf.keras.Model([inputs, targets], logits)"
  ],
  "consequent": [
   "return tf.keras.Model([inputs, targets], logits)"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "def benchmark_1_gpu_no_dist_strat_force_v2_early_stop(self):"
  ],
  "consequent": [
   "def benchmark_1_gpu_no_dist_strat_run_eagerly_early_stop(self):"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "MIN_TOP_1_ACCURACY = 0.929"
  ],
  "consequent": [
   "MIN_TOP_1_ACCURACY = 0.925"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "tf_data_experimental_slack=False, enable_xla=False,"
  ],
  "consequent": [
   "tf_data_experimental_slack=False, enable_xla=False):"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "def _run_and_report_benchmark(self,"
  ],
  "consequent": [
   "def _run_and_report_benchmark(self):"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "enable_xla=True,"
  ],
  "consequent": [
   "enable_xla=True)"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "top_1_min=top_1_min,",
   "top_1_max=top_1_max,"
  ],
  "consequent": [
   "top_1_min=MIN_TOP_1_ACCURACY,",
   "top_1_max=MAX_TOP_1_ACCURACY,"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "run_eagerly=FLAGS.run_eagerly,"
  ],
  "consequent": [
   "run_eagerly=FLAGS.run_eagerly)"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "\"\"\"Benchmark 1 gpu without distribution strategies.\"\"\""
  ],
  "consequent": [
   "\"\"\"Benchmark 1 gpu.\"\"\""
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "enable_xla=True,"
  ],
  "consequent": [
   "enable_xla=True"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "self._run_and_report_benchmark(top_1_min=0.736)"
  ],
  "consequent": [
   "self._run_and_report_benchmark()"
  ]
 },
 {
  "sha": "9d8c9aa4b4370dd6a1145cbb1624ab995a64dbbb",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 08:27:23",
  "condition": [
   "run_eagerly=flags_obj.run_eagerly,"
  ],
  "consequent": [
   "run_eagerly=flags_obj.run_eagerly)"
  ]
 },
 {
  "sha": "8390b3622284499df8f94f12ce27564b92c9c7c0",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 00:45:46",
  "condition": [
   "time_callback = keras_utils.TimeHistory(flags_obj.batch_size,"
  ],
  "consequent": [
   "time_callback = keras_utils.TimeHistory(flags_obj.batch_size, 100)"
  ]
 },
 {
  "sha": "8390b3622284499df8f94f12ce27564b92c9c7c0",
  "author": "Toby Boyd",
  "created_at": "2019-07-24 00:45:46",
  "condition": [
   "top_1_train_min=None, log_steps=FLAGS.log_steps)"
  ],
  "consequent": [
   "top_1_train_min=None)"
  ]
 },
 {
  "sha": "448c31b6c688f93082ae5e51e9d5f0d1652b0ac1",
  "author": "Zongwei Zhou",
  "created_at": "2019-07-13 02:27:50",
  "condition": [
   "# Note that softmax internally performs math operations using float32",
   "# for numeric stability. When training with float16, we keep the input",
   "# and output in float16 for better performance.",
   "weights = tf.nn.softmax(logits, name=\"attention_weights\")"
  ],
  "consequent": [
   "weights = _float32_softmax(logits, name=\"attention_weights\")"
  ]
 },
 {
  "sha": "49b90e86b0b31d3e6b03373e097809d0e10016b9",
  "author": "Toby Boyd",
  "created_at": "2019-07-20 03:15:25",
  "condition": [
   "return tf2.enabled()"
  ],
  "consequent": [
   "if hasattr(tf, 'contrib'):",
   "  return False",
   "else:",
   "  return True"
  ]
 },
 {
  "sha": "308c79344c144290d431f777fc47deb5c94ccc80",
  "author": "Toby Boyd",
  "created_at": "2019-07-20 03:09:41",
  "condition": [
   "if not keras_utils.is_v2_0() and strategy is not None:"
  ],
  "consequent": [
   "if keras_utils.is_v2_0() and strategy is not None:"
  ]
 },
 {
  "sha": "2569fa9a88738b37d665b3459333133e8607dd83",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 23:03:02",
  "condition": [
   "if hasattr(tf, 'contrib'):",
   "  return False",
   "else:",
   "  return True"
  ],
  "consequent": [
   "from tensorflow.python import tf2",
   "return tf2.enabled()"
  ]
 },
 {
  "sha": "712f473e47dc3df04cc4d0e761869e38bf3e175b",
  "author": "guptapriya",
  "created_at": "2019-07-19 09:54:54",
  "condition": [
   "from tensorflow.python import tf2",
   "return tf2.enabled()"
  ],
  "consequent": [
   "if hasattr(tf, 'contrib'):",
   "  return False",
   "else:",
   "  return True"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "def run(flags_obj):",
   "  \"\"\"Run Shakespeare training and predict."
  ],
  "consequent": [
   "def main(_):",
   "  flags_obj = flags.FLAGS"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   " keras_utils.set_session_config(",
   "     enable_eager=flags_obj.enable_eager,",
   "     enable_xla=flags_obj.enable_xla)",
   " strategy = distribution_utils.get_distribution_strategy(",
   "     distribution_strategy=flags_obj.distribution_strategy,",
   "     num_gpus=flags_obj.num_gpus)",
   " dataset, idx2char, char2idx = get_dataset(flags_obj.training_data,"
  ],
  "consequent": [
   " dataset, idx2char, char2idx = get_dataset(flags_obj.training_data)"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "def train_model(flags_obj, dataset, vocab_size, strategy, checkpoint_dir=None):"
  ],
  "consequent": [
   "def train_model(dataset, vocab_size, checkpoint_dir=None):"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "with open(path_to_file, 'rb') as train_data:",
   "  text = train_data.read().decode(encoding='utf-8')"
  ],
  "consequent": [
   "text = open(path_to_file, 'rb').read().decode(encoding='utf-8')"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "log_steps: Interval of steps between logging of batch level stats."
  ],
  "consequent": [
   "log_steps: Interval of time history logs."
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   " flags_core.define_base(data_dir=False,",
   "                        clean=False,",
   "                        train_epochs=True,",
   "                        epochs_between_evals=False,",
   "                        stop_threshold=False,",
   "                        hooks=False,",
   "                        export_dir=False,",
   "                        run_eagerly=True)",
   " flags_core.define_performance(num_parallel_calls=False,",
   "                               inter_op=False,",
   "                               intra_op=False,",
   "                               synthetic_data=False,",
   "                               max_train_steps=False,",
   "                               dtype=False,",
   "                               enable_xla=True)",
   " flags_core.set_defaults(train_epochs=43,",
   "                         batch_size=64)",
   " flags.DEFINE_boolean(name='enable_eager', default=True, help='Enable eager?')"
  ],
  "consequent": [
   "flags.DEFINE_string(",
   "    name='model_dir', default=None,",
   "    help='Directory for model check points.')"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "def get_dataset(path_to_file, batch_size=None, seq_length=SEQ_LENGTH):"
  ],
  "consequent": [
   "def get_dataset(path_to_file, seq_length=SEQ_LENGTH):"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "train_steps = BATCHES_PER_EPOCH // flags_obj.batch_size",
   "strategy_scope = distribution_utils.get_strategy_scope(strategy)"
  ],
  "consequent": [
   "strategy = tf.distribute.MirroredStrategy()"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "with strategy_scope:"
  ],
  "consequent": [
   "with strategy.scope():"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "The training history and callbacks."
  ],
  "consequent": [
   "The training history."
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "batch_size=None,"
  ],
  "consequent": [
   "batch_size=BATCH_SIZE,"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "tf.keras.metrics.Recall(top_k=5, name='RecallAt5')],"
  ],
  "consequent": [
   "tf.keras.metrics.Recall(top_k=5, name='RecallAt5')])"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "time_callback = keras_utils.TimeHistory(flags_obj.batch_size, 100)",
   "callbacks.append(time_callback)",
   "history = model.fit(dataset,",
   "                    epochs=flags_obj.train_epochs,",
   "                    steps_per_epoch=train_steps,",
   "                    callbacks=callbacks,",
   "                    verbose=2)",
   "return history, callbacks"
  ],
  "consequent": [
   " return model.fit(dataset, epochs=EPOCHS, callbacks=callbacks)"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "\"\"\"Callback for logging performance."
  ],
  "consequent": [
   "\"\"\"Callback for logging performance (# examples/second)."
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "   history, callbacks = train_model(flags_obj, dataset,",
   "                                    len(idx2char), strategy,",
   "                                    checkpoint_dir=flags_obj.model_dir)",
   "   stats['history'] = history.history",
   "   stats['callbacks'] = callbacks"
  ],
  "consequent": [
   "train_model(dataset, len(idx2char), flags_obj.model_dir)"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "model = build_model(vocab_size=vocab_size, batch_size=flags_obj.batch_size)"
  ],
  "consequent": [
   "model = build_model(vocab_size=vocab_size)"
  ]
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "import numpy as np"
  ],
  "consequent": []
 },
 {
  "sha": "e0a2b8c35815e93c4c8abade84a56c1f092b411c",
  "author": "Toby Boyd",
  "created_at": "2019-07-19 07:04:22",
  "condition": [
   "dataset = dataset.shuffle(10000).repeat()",
   "dataset = dataset.batch(batch_size, drop_remainder=True)"
  ],
  "consequent": [
   "dataset = dataset.shuffle(10000).batch(BATCH_SIZE, drop_remainder=True)"
  ]
 },
 {
  "sha": "dd5a91d3c0c5df38e78c2700d997c9b7dc56d268",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-19 03:04:37",
  "condition": [
   "input_context=None,"
  ],
  "consequent": [
   "input_context=None):"
  ]
 },
 {
  "sha": "dd5a91d3c0c5df38e78c2700d997c9b7dc56d268",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-19 03:04:37",
  "condition": [
   " keras_utils.set_session_config(",
   "     enable_eager=flags_obj.enable_eager,",
   "     enable_xla=flags_obj.enable_xla,",
   "     enable_grappler_layout_optimizer=",
   "     flags_obj.enable_grappler_layout_optimizer)",
   " # Execute flag override logic for better model performance",
   " if flags_obj.tf_gpu_thread_mode:",
   "   keras_common.set_gpu_thread_mode_and_count(flags_obj)",
   " keras_common.set_cudnn_batchnorm_mode()"
  ],
  "consequent": [
   "keras_utils.set_session_config(enable_eager=flags_obj.enable_eager,",
   "                               enable_xla=flags_obj.enable_xla)"
  ]
 },
 {
  "sha": "dd5a91d3c0c5df38e78c2700d997c9b7dc56d268",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-19 03:04:37",
  "condition": [
   "dtype=flags_core.get_tf_dtype(flags_obj),"
  ],
  "consequent": [
   "dtype=flags_core.get_tf_dtype(flags_obj))"
  ]
 },
 {
  "sha": "dd5a91d3c0c5df38e78c2700d997c9b7dc56d268",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-19 03:04:37",
  "condition": [
   "dtype=dtype,"
  ],
  "consequent": [
   "dtype=dtype)"
  ]
 },
 {
  "sha": "dd5a91d3c0c5df38e78c2700d997c9b7dc56d268",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-19 03:04:37",
  "condition": [
   "datasets_num_private_threads=datasets_num_private_threads,"
  ],
  "consequent": [
   "datasets_num_private_threads=datasets_num_private_threads"
  ]
 },
 {
  "sha": "492f8c92a24cda084861307f2b8757aee192fba8",
  "author": "nnigania",
  "created_at": "2019-07-17 02:34:12",
  "condition": [
   "\"\"\"CTL does metric calculation as part of eval_step function\"\"\"",
   "if not params[\"keras_use_ctl\"]:",
   "  softmax_logits = MetricLayer(params)([softmax_logits, dup_mask_input])"
  ],
  "consequent": [
   "softmax_logits = MetricLayer(params)([softmax_logits, dup_mask_input])"
  ]
 },
 {
  "sha": "492f8c92a24cda084861307f2b8757aee192fba8",
  "author": "nnigania",
  "created_at": "2019-07-17 02:34:12",
  "condition": [
   "                                                drop_remainder=True)",
   "eval_input_dataset = eval_input_dataset.batch(batches_per_step,"
  ],
  "consequent": [
   "eval_input_dataset = eval_input_dataset.batch(batches_per_step)"
  ]
 },
 {
  "sha": "492f8c92a24cda084861307f2b8757aee192fba8",
  "author": "nnigania",
  "created_at": "2019-07-17 02:34:12",
  "condition": [
   "# drop_remainder = True, as we would like batch call to return a fixed shape",
   "# vs None, this prevents a expensive broadcast during weighted_loss",
   "train_input_dataset = train_input_dataset.batch(batches_per_step,"
  ],
  "consequent": [
   "train_input_dataset = train_input_dataset.batch(batches_per_step)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if shape_utils.get_dim_as_int(scores.shape[1]) is None:"
  ],
  "consequent": [
   "if scores.shape[1].value is None:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return out_tensor_dict"
  ],
  "consequent": [
   "return tensor_dict"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   " elif (calibration_config.WhichOneof('calibrator') ==",
   "       'class_id_function_approximations'):",
   "   def calibration_fn(class_predictions_with_background):",
   "     \"\"\"Calibrate predictions per class via 1-d linear interpolation.",
   "     Prediction scores are linearly interpolated with class-specific function",
   "     approximations. Note that after calibration, an anchor's class scores will",
   "     not necessarily sum to 1, and score ordering may change, depending on each",
   "     class' calibration parameters.",
   "     Args:",
   "       class_predictions_with_background: tf.float32 tensor of shape",
   "         [batch_size, num_anchors, num_classes + 1] containing scores on the",
   "         interval [0,1]. This is usually produced by a sigmoid or softmax layer",
   "         and the result of calling the `predict` method of a detection model.",
   "     Returns:",
   "       tf.float32 tensor of the same shape as the input with values on the",
   "       interval [0, 1].",
   "     Raises:",
   "       KeyError: Calibration parameters are not present for a class.",
   "     \"\"\"",
   "     class_id_function_dict = _get_class_id_function_dict(calibration_config)",
   "     # Tensors are split by class and then recombined at the end to recover",
   "     # the input's original shape. If a class id does not have calibration",
   "     # parameters, it is left unchanged.",
   "     class_tensors = tf.unstack(class_predictions_with_background, axis=-1)",
   "     calibrated_class_tensors = []",
   "     for class_id, class_tensor in enumerate(class_tensors):",
   "       flat_class_tensor = tf.reshape(class_tensor, shape=[-1])",
   "       if class_id in class_id_function_dict:",
   "         output_tensor = _tf_linear_interp1d(",
   "             x_to_interpolate=flat_class_tensor,",
   "             fn_x=class_id_function_dict[class_id][0],",
   "             fn_y=class_id_function_dict[class_id][1])",
   "       else:",
   "         tf.logging.info(",
   "             'Calibration parameters for class id `%d` not not found',",
   "             class_id)",
   "         output_tensor = flat_class_tensor",
   "       calibrated_class_tensors.append(output_tensor)",
   "     combined_calibrated_tensor = tf.stack(calibrated_class_tensors, axis=1)",
   "     input_shape = shape_utils.combined_static_and_dynamic_shape(",
   "         class_predictions_with_background)",
   "     calibrated_class_predictions_with_background = tf.reshape(",
   "         combined_calibrated_tensor,",
   "         shape=input_shape,",
   "         name='calibrate_scores')",
   "     return calibrated_class_predictions_with_background",
   " # TODO(zbeaver): Add sigmoid calibration."
  ],
  "consequent": [
   "# TODO(zbeaver): Add sigmoid calibration and per-class isotonic regression."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "depth_multiplier,",
   "pad_to_multiple,",
   "use_keras=use_keras,",
   "use_depthwise=use_depthwise)"
  ],
  "consequent": [
   "depth_multiplier, pad_to_multiple, use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_masks = self.groundtruth_masks.pop(image_key)"
  ],
  "consequent": [
   "groundtruth_masks = self.groundtruth_masks.pop(",
   "    image_key)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "perm=[2, 0, 1]),"
  ],
  "consequent": [
   "perm=[2, 0, 1])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _create_feature_extractor(self,",
   "                              depth_multiplier,",
   "                              pad_to_multiple,",
   "                              is_training=True,",
   "                              use_explicit_padding=False,"
  ],
  "consequent": [
   "def _create_feature_extractor(self, depth_multiplier, pad_to_multiple,",
   "                              is_training=True, use_explicit_padding=False,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "weight_decay: See base class."
  ],
  "consequent": [
   "reuse_weights: See base class."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "              ][:self._num_layers],",
   "'layer_depth': [-1, -1, -1, 512, 256, 128][:self._num_layers],"
  ],
  "consequent": [
   "'layer_depth': [-1, -1, -1, 512, 256, 128],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "containing `num_boxes` groundtruth masks. The mask values range from 0",
   "to 1."
  ],
  "consequent": [
   "[num_boxes, height, width] containing `num_boxes` groundtruth masks.",
   "The mask values range from 0 to 1."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "@parameterized.named_parameters(('', False), ('_use_static_shapes', True))",
   "def test_batch_multiclass_nms_with_batch_size_1(self, use_static_shapes):"
  ],
  "consequent": [
   "def test_batch_multiclass_nms_with_batch_size_1(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def expand_boxes_or_segments_from_csv(self, csv_row,"
  ],
  "consequent": [
   "def expand_boxes_from_csv(self, csv_row):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if fields.InputDataFields.groundtruth_boxes in out_tensor_dict:"
  ],
  "consequent": [
   "if fields.InputDataFields.groundtruth_boxes in tensor_dict:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class MinibatchSampler(six.with_metaclass(ABCMeta, object)):"
  ],
  "consequent": [
   "class MinibatchSampler(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "dataset_util.bytes_feature(six.b('jpeg')),"
  ],
  "consequent": [
   "dataset_util.bytes_feature('jpeg'),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class Matcher(six.with_metaclass(abc.ABCMeta, object)):"
  ],
  "consequent": [
   "class Matcher(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _create_feature_extractor(self,",
   "                              depth_multiplier,",
   "                              pad_to_multiple,",
   "                              use_explicit_padding=False,",
   "                              num_layers=6,"
  ],
  "consequent": [
   "def _create_feature_extractor(self, depth_multiplier, pad_to_multiple,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "kwargs = conv_hyperparams.params()",
   "# Both the regularizer and initializer apply to the depthwise layer,",
   "# so we remap the kernel_* to depthwise_* here.",
   "kwargs['depthwise_regularizer'] = kwargs['kernel_regularizer']",
   "kwargs['depthwise_initializer'] = kwargs['kernel_initializer']",
   "layers.append(",
   "    tf.keras.layers.SeparableConv2D("
  ],
  "consequent": [
   "layers.append(tf.keras.layers.SeparableConv2D(",
   "    depth,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class BatchMulticlassNonMaxSuppressionTest(test_case.TestCase,"
  ],
  "consequent": [
   "class BatchMulticlassNonMaxSuppressionTest(test_case.TestCase):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "first_box_key = next(six.iterkeys(groundtruth_box_tuples.dtype.fields))"
  ],
  "consequent": [
   "first_box_key = groundtruth_box_tuples.dtype.fields.keys()[0]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self).__init__('resnet_v1_50', resnet_v1.resnet_v1_50, is_training,"
  ],
  "consequent": [
   "'resnet_v1_50', resnet_v1.resnet_v1_50, is_training,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "whether a ground truth box is a group-of box or not. To support the case"
  ],
  "consequent": [
   "whether a ground truth box is a group-of box or not. To support"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "import copy"
  ],
  "consequent": [
   "import argparse"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class BoxCoder(six.with_metaclass(ABCMeta, object)):"
  ],
  "consequent": [
   "class BoxCoder(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self.assertTrue(",
   "    any('FusedBatchNorm' in op.type",
   "        for op in tf.get_default_graph().get_operations()))"
  ],
  "consequent": [
   "self.assertTrue(any(op.type == 'FusedBatchNorm'",
   "                    for op in tf.get_default_graph().get_operations()))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _create_feature_extractor(self,",
   "                              depth_multiplier,",
   "                              pad_to_multiple,",
   "                              use_explicit_padding=False,"
  ],
  "consequent": [
   "def _create_feature_extractor(self, depth_multiplier, pad_to_multiple,",
   "                              is_training=True, use_explicit_padding=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if use_keras:",
   "  return (ssd_resnet_v1_fpn_keras_feature_extractor.",
   "          SSDResNet152V1FpnKerasFeatureExtractor(",
   "              is_training=is_training,",
   "              depth_multiplier=depth_multiplier,",
   "              min_depth=min_depth,",
   "              pad_to_multiple=pad_to_multiple,",
   "              conv_hyperparams=self._build_conv_hyperparams(",
   "                  add_batch_norm=False),",
   "              freeze_batchnorm=False,",
   "              inplace_batchnorm_update=False,",
   "              name='ResNet152V1_FPN'))",
   "else:",
   "  return ("
  ],
  "consequent": [
   "return ("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "batch_size = tf.shape(feature_grid_y)[0]"
  ],
  "consequent": [
   "batch_size = feature_grid_y.shape[0].value"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "sample_1_of_n_eval_examples=None,"
  ],
  "consequent": [
   "sample_1_of_n_eval_examples=1,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_returns_correct_shapes_256(self, use_keras):"
  ],
  "consequent": [
   "def test_extract_features_returns_correct_shapes_256(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "function approximation. Note that the 0-indexed background class is also"
  ],
  "consequent": [
   "function approximations. Note that the 0-indexed background class may"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   " del unused_args",
   " with open(FLAGS.json_hierarchy_file) as f:"
  ],
  "consequent": [
   "with open(parsed_args.json_hierarchy_file) as f:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_class_labels: An integer numpy array of length M, representing"
  ],
  "consequent": [
   "groundtruth_class_labels: An integer numpy array of length M,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "True, mask evaluation will be performed instead."
  ],
  "consequent": [
   "If True, mask evaluation will be performed instead."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "category_name = six.text_type(category_name, 'utf-8')"
  ],
  "consequent": [
   "category_name = unicode(category_name, 'utf-8')"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/encoded':",
   "    dataset_util.bytes_feature(encoded_jpeg),"
  ],
  "consequent": [
   "'image/encoded': dataset_util.bytes_feature(encoded_jpeg),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "Tout=["
  ],
  "consequent": [
   "Tout=[",
   "    o.type"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "params=params if params else {})"
  ],
  "consequent": [
   "params=params if params else {},",
   "**kwargs)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "per_image_eval_class: The class that contains functions for computing per"
  ],
  "consequent": [
   "per_image_eval_class: The class that contains functions for computing"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for child, _ in all_keyed_child.items():"
  ],
  "consequent": [
   "for child, _ in all_keyed_child.iteritems():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "super(FasterRCNNResnet101FeatureExtractor,"
  ],
  "consequent": [
   "super(FasterRCNNResnet101FeatureExtractor, self).__init__("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_raises_error_with_invalid_image_size("
  ],
  "consequent": [
   "def test_extract_features_raises_error_with_invalid_image_size(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if (standard_fields.InputDataFields.groundtruth_group_of in six.viewkeys("
  ],
  "consequent": [
   "if (standard_fields.InputDataFields.groundtruth_group_of in"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_boxes],"
  ],
  "consequent": [
   "tf.shape(tensor_dict[fields.InputDataFields.groundtruth_boxes])[0],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self).__init__('resnet_v1_152', resnet_v1.resnet_v1_152, is_training,"
  ],
  "consequent": [
   "'resnet_v1_152', resnet_v1.resnet_v1_152, is_training,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "of shape [num_boxes, height, width] containing `num_boxes` masks of"
  ],
  "consequent": [
   "array of shape [num_boxes, height, width] containing `num_boxes` masks"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_variables_only_created_in_scope(self, use_keras):"
  ],
  "consequent": [
   "def test_variables_only_created_in_scope(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_preprocess_returns_correct_value_range(self, use_keras,"
  ],
  "consequent": [
   "def test_preprocess_returns_correct_value_range(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "evaluate_corlocs: (optional) boolean which determines if corloc scores are"
  ],
  "consequent": [
   "evaluate_corlocs: (optional) boolean which determines if corloc scores"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "args.extend(six.itervalues(eval_dict_filtered))"
  ],
  "consequent": [
   "args.extend(eval_dict_filtered.values())"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_class_labels[groundtruth_is_group_of_list"
  ],
  "consequent": [
   "groundtruth_class_labels[groundtruth_is_group_of_list] == class_index)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_returns_correct_shapes_with_depth_multiplier("
  ],
  "consequent": [
   "def test_extract_features_returns_correct_shapes_with_depth_multiplier(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "six.b(''),"
  ],
  "consequent": [
   "'',"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/filename': dataset_util.bytes_feature(six.b('filename'))"
  ],
  "consequent": [
   "'image/filename': dataset_util.bytes_feature('filename')"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "[batch_size, max_detections, 4] which represents the bounding boxes."
  ],
  "consequent": [
   "[batch_size, max_detection, 4] which represents the bounding boxes."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "reuse_weights: See base class."
  ],
  "consequent": [
   "first_stage_features_stride: See base class.",
   "batch_norm_trainable: See base class."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "tf.transpose(prediction_dict[RPN_BOX_ENCODINGS], perm=[2, 0, 1]),"
  ],
  "consequent": [
   "prediction_dict[RPN_BOX_ENCODINGS], perm=[2, 0, 1])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "standard_fields.InputDataFields.groundtruth_group_of: Optional length M"
  ],
  "consequent": [
   "standard_fields.InputDataFields.groundtruth_group_of: Optional length"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if shape_utils.get_dim_as_int(boxes.shape[2]) != 4:"
  ],
  "consequent": [
   "if boxes.shape[2].value != 4:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "first_box_key = next(six.iterkeys(detections_box_tuples.dtype.fields))"
  ],
  "consequent": [
   "first_box_key = detections_box_tuples.dtype.fields.keys()[0]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "q = shape_utils.get_dim_as_int(boxes.shape[1])"
  ],
  "consequent": [
   "q = boxes.shape[1].value"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _resnet_scope_name(self, use_keras=False):"
  ],
  "consequent": [
   "def _resnet_scope_name(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'from_layer': ['layer_15/expansion_output', 'layer_19', '', '', '', ''"
  ],
  "consequent": [
   "'from_layer': ['layer_15/expansion_output', 'layer_19', '', '', '', ''],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict = tensor_dict.copy()"
  ],
  "consequent": [
   "# Reshape flattened multiclass scores tensor into a 2D tensor of shape",
   "# [num_boxes, num_classes]."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._activation_fn = activation_fn",
   "super(FasterRCNNResnetV1FeatureExtractor,"
  ],
  "consequent": [
   "super(FasterRCNNResnetV1FeatureExtractor, self).__init__("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_boxes: float32 numpy array of shape [num_boxes, 4] containing"
  ],
  "consequent": [
   "groundtruth_boxes: float32 numpy array of shape [num_boxes, 4]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "numpy boolean array denoting whether a ground truth box is a difficult"
  ],
  "consequent": [
   "M numpy boolean array denoting whether a ground truth box is a"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._mean_average_precision = np.mean(",
   "    list(self._average_precisions.values()))"
  ],
  "consequent": [
   "self._mean_average_precision = np.mean(self._average_precisions.values())"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "This function extracts box features for each box in rpn_features_to_crop.",
   "It returns the extracted box features, reshaped to",
   "[batch size, max_detections, height, width, depth], and average pools",
   "the extracted features across the spatial dimensions and adds a graph node",
   "to the pooled features named 'pooled_detection_features'"
  ],
  "consequent": [
   "The detection features are from cropping rpn_features with boxes.",
   "Each bounding box has one feature vector of length depth, which comes from",
   "mean_pooling of the cropped rpn_features."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "detected_boxes: float32 numpy array of shape [num_boxes, 4] containing"
  ],
  "consequent": [
   "detected_boxes: float32 numpy array of shape [num_boxes, 4]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def main(unused_args):"
  ],
  "consequent": [
   "def main(parsed_args):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/format': dataset_util.bytes_feature(six.b('jpeg')),"
  ],
  "consequent": [
   "'image/format': dataset_util.bytes_feature('jpeg'),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._extract_features("
  ],
  "consequent": [
   "self._extract_features(preprocessed_inputs,",
   "                       depth_multiplier,",
   "                       pad_to_multiple,",
   "                       use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image = tf.constant(",
   "    list(range(1, 3 * 2 + 1)) * 6, dtype=tf.float32, shape=image_shape)"
  ],
  "consequent": [
   "image = tf.constant(range(1, 3 * 2 + 1) * 6, dtype=tf.float32,",
   "                    shape=image_shape)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "super(FasterRCNNResnet152FeatureExtractor,"
  ],
  "consequent": [
   "super(FasterRCNNResnet152FeatureExtractor, self).__init__("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if FLAGS.annotation_type == 2:"
  ],
  "consequent": [
   "if parsed_args.annotation_type == 2:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "`num_boxes` detection boxes of the format [ymin, xmin, ymax, xmax] in",
   "absolute image coordinates."
  ],
  "consequent": [
   "containing `num_boxes` detection boxes of the format",
   "[ymin, xmin, ymax, xmax] in absolute image coordinates."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "true_feature_shapes = tf.stack([tf.shape(feature)[1:3]",
   "                                for feature in features])"
  ],
  "consequent": [
   "true_feature_shapes = tf.stack([feature.shape[1:3] for feature in features])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "super(FasterRCNNResnet50FeatureExtractor,"
  ],
  "consequent": [
   "super(FasterRCNNResnet50FeatureExtractor, self).__init__("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "None)[0], tf.uint8)"
  ],
  "consequent": [
   "tf.uint8)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_dict) and"
  ],
  "consequent": [
   "groundtruth_dict.keys() and"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class AnchorGenerator(six.with_metaclass(ABCMeta, object)):"
  ],
  "consequent": [
   "class AnchorGenerator(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_keyed_parent[hierarchy['LabelName']] = copy.deepcopy(all_children)"
  ],
  "consequent": [
   "all_keyed_parent[hierarchy['LabelName']] = all_children"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "split_csv_row[labelname_column_index] = child_node"
  ],
  "consequent": [
   "cvs_row_splited[2] = child_node"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_classes],",
   "num_classes)"
  ],
  "consequent": [
   "num_classes"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "encoding1, 0.8"
  ],
  "consequent": [
   "encoding1['counts'], 0.8"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _extract_features(self,",
   "                      image_tensor,",
   "                      depth_multiplier,",
   "                      pad_to_multiple,",
   "                      use_explicit_padding=False,"
  ],
  "consequent": [
   "def _extract_features(self, image_tensor, depth_multiplier, pad_to_multiple,",
   "                      use_explicit_padding=False, use_keras=False):",
   "  try:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "use_explicit_padding=False, min_depth=32,"
  ],
  "consequent": [
   "use_explicit_padding=False, min_depth=32):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image = out_tensor_dict[fields.InputDataFields.image]"
  ],
  "consequent": [
   "image = tensor_dict[fields.InputDataFields.image]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "expected_feature_map_shape, use_keras=use_keras)"
  ],
  "consequent": [
   "expected_feature_map_shape)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "depth_multiplier, pad_to_multiple, use_keras=use_keras)"
  ],
  "consequent": [
   "pad_to_multiple,",
   "use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.true_image_shape] = tf.squeeze("
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.true_image_shape] = tf.squeeze("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if int(split_csv_row[confidence_column_index]) == 1:",
   "  assert split_csv_row[",
   "      labelname_column_index] in self._hierarchy_keyed_child",
   "  parent_nodes = self._hierarchy_keyed_child["
  ],
  "consequent": [
   "if int(cvs_row_splited[3]) == 1:",
   "  assert cvs_row_splited[2] in self._hierarchy_keyed_child",
   "  parent_nodes = self._hierarchy_keyed_child[cvs_row_splited[2]]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self.assertItemsEqual(list(out_variables.keys()), ['ckpt_weights'])"
  ],
  "consequent": [
   "self.assertItemsEqual(out_variables.keys(), ['ckpt_weights'])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "logging.warning('No groundtruth for the image with id %s.', image_id)"
  ],
  "consequent": [
   "logging.warn('No groundtruth for the image with id %s.', image_id)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image_resizer_fn(out_tensor_dict[fields.InputDataFields.image],"
  ],
  "consequent": [
   "image_resizer_fn(tensor_dict[fields.InputDataFields.image], None)[0],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "                                     selected_indices)",
   "  else:",
   "    if soft_nms_sigma != 0:",
   "      raise ValueError('Soft NMS not supported in current TF version!')",
   "    selected_indices = tf.image.non_max_suppression(",
   "        boxlist_and_class_scores.get(),",
   "        boxlist_and_class_scores.get_field(fields.BoxListFields.scores),",
   "        max_selection_size,",
   "        iou_threshold=iou_thresh,",
   "        score_threshold=score_thresh)",
   "    num_valid_nms_boxes = tf.shape(selected_indices)[0]",
   "    selected_indices = tf.concat(",
   "        [selected_indices,",
   "         tf.zeros(max_selection_size-num_valid_nms_boxes, tf.int32)], 0)",
   "    nms_result = box_list_ops.gather(boxlist_and_class_scores,",
   "                                     selected_indices)",
   "    selected_scores = nms_result.get_field(fields.BoxListFields.scores)",
   "valid_nms_boxes_indices = tf.less("
  ],
  "consequent": [
   "valid_nms_boxes_indx = tf.less("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _resnet_scope_name(self, use_keras):"
  ],
  "consequent": [
   "def _resnet_scope_name(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "2,",
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,",
   "expected_feature_map_shape,",
   "use_explicit_padding=True,",
   "use_keras=use_keras,"
  ],
  "consequent": [
   "2, image_height, image_width, depth_multiplier, pad_to_multiple,",
   "expected_feature_map_shape, use_explicit_padding=True,",
   "use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "boxlist_and_class_scores.data['boxes'],",
   "boxlist_and_class_scores.data['scores'],",
   "argsort_ids) = partitioned_non_max_suppression_padded(",
   "    boxlist_and_class_scores.get(),"
  ],
  "consequent": [
   "boxlist_and_class_scores.get(),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def expand_labels_from_csv(self,"
  ],
  "consequent": [
   "def expand_labels_from_csv(self, csv_row):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "warmup_steps = list(range(boundaries[0]))"
  ],
  "consequent": [
   "warmup_steps = range(boundaries[0])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "with open(FLAGS.output_annotations, 'w') as target:"
  ],
  "consequent": [
   "with open(parsed_args.output_annotations, 'w') as target:",
   "  header = None"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "values ranging between 0 and 1."
  ],
  "consequent": [
   "of values ranging between 0 and 1."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "bbox_classes_text = [six.b('cat'), six.b('dog')]"
  ],
  "consequent": [
   "bbox_classes_text = ['cat', 'dog']"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "group_of_weight=0.0)"
  ],
  "consequent": [
   "group_of_weight=1.0)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._num_gt_instances_per_relationship)):"
  ],
  "consequent": [
   "self._num_gt_instances_per_relationship.iteritems()):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for key, value_op in six.iteritems(value_ops_out):"
  ],
  "consequent": [
   "for key, value_op in value_ops_out.iteritems():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_get_expected_feature_map_variable_names(self, use_keras,"
  ],
  "consequent": [
   "def test_get_expected_feature_map_variable_names(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "     function_approximation = (",
   "         calibration_proto.function_approximation.x_y_pairs)"
  ],
  "consequent": [
   "label_function_approximation = (calibration_proto",
   "                                .function_approximation",
   "                                .x_y_pairs)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,",
   "use_keras=use_keras,"
  ],
  "consequent": [
   "image_height, image_width, depth_multiplier, pad_to_multiple,",
   "use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "selected_scores = tf.concat(",
   "    [selected_scores,",
   "     tf.zeros(max_selection_size-num_valid_nms_boxes, tf.float32)], -1)",
   "nms_result = box_list_ops.gather(boxlist_and_class_scores,"
  ],
  "consequent": [
   "   nms_result = box_list_ops.gather(boxlist_and_class_scores, selected_indices)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "depth_multiplier, pad_to_multiple, min_depth=min_depth,"
  ],
  "consequent": [
   "depth_multiplier, pad_to_multiple, min_depth=min_depth)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "result.append(','.join(split_csv_row))"
  ],
  "consequent": [
   "result.append(','.join(cvs_row_splited))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "assert split_csv_row[",
   "    labelname_column_index] in self._hierarchy_keyed_child",
   "parent_nodes = self._hierarchy_keyed_child["
  ],
  "consequent": [
   "assert cvs_row_splitted[2] in self._hierarchy_keyed_child",
   "parent_nodes = self._hierarchy_keyed_child[cvs_row_splitted[2]]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "add_detection_keypoints=True, add_detection_masks=True,"
  ],
  "consequent": [
   "add_detection_keypoints=True, add_detection_masks=True)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "feature_extractor = self._create_feature_extractor("
  ],
  "consequent": [
   "feature_extractor = self._create_feature_extractor(depth_multiplier,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "selected_scores, -1*tf.ones(max_selection_size)))"
  ],
  "consequent": [
   "nms_scores, -1*tf.ones(max_selection_size)))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def __init__(self, add_detection_keypoints=False, add_detection_masks=False,"
  ],
  "consequent": [
   "def __init__(self, add_detection_keypoints=False, add_detection_masks=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "valid_nms_boxes_indices = tf.less("
  ],
  "consequent": [
   "valid_nms_boxes_indx = tf.less("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "expanded_lines = (",
   "    expansion_generator.expand_boxes_or_segments_from_csv("
  ],
  "consequent": [
   "expanded_lines = expansion_generator.expand_boxes_from_csv(line)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "use_explicit_padding=use_explicit_padding,"
  ],
  "consequent": [
   "use_explicit_padding=use_explicit_padding)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "eval_dict_keys = list(eval_dict_filtered.keys())"
  ],
  "consequent": [
   "eval_dict_keys = eval_dict_filtered.keys()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   ".SSDMobileNetV2FpnKerasFeatureExtractor("
  ],
  "consequent": [
   "SSDMobileNetV2FpnKerasFeatureExtractor("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'LabelName':"
  ],
  "consequent": [
   "'LabelName': 'c',"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return tf.contrib.tpu.rewrite(tpu_subgraph_predict_fn,"
  ],
  "consequent": [
   "return tf.contrib.tpu.rewrite(tpu_subgraph_first_stage_fn,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "additional_fields=per_image_additional_fields,"
  ],
  "consequent": [
   "additional_fields=per_image_additional_fields)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "images = tf.constant(",
   "    list(range(1, 2 * 2 * 4 + 1)) * 2, dtype=tf.float32, shape=image_shape)"
  ],
  "consequent": [
   "images = tf.constant(range(1, 2 * 2 * 4  + 1) * 2, dtype=tf.float32,",
   "                     shape=image_shape)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "np_data = pd.DataFrame([["
  ],
  "consequent": [
   "np_data = pd.DataFrame(",
   "    [["
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "1.0)"
  ],
  "consequent": [
   "0.5)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "containing `num_boxes` detection masks with values ranging between 0 and"
  ],
  "consequent": [
   "containing `num_boxes` detection masks with values ranging"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "calibration_config, class_agnostic_x, class_agnostic_y, class_id=None)"
  ],
  "consequent": [
   "class_agnostic_x,",
   "class_agnostic_y,",
   "class_label=None)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_boxes],"
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.groundtruth_boxes],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "transformed."
  ],
  "consequent": [
   "also transformed."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "a valid scores field or if non-zero soft_nms_sigma is provided when",
   "pad_to_max_output_size is True."
  ],
  "consequent": [
   "a valid scores field."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "tf.transpose("
  ],
  "consequent": [
   "rpn_objectness_predictions_with_background = tf.transpose("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "ground-truth boxes."
  ],
  "consequent": [
   "to ground-truth boxes."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "feature_maps = self._extract_features("
  ],
  "consequent": [
   "feature_maps = self._extract_features(preprocessed_inputs,",
   "                                      depth_multiplier,",
   "                                      pad_to_multiple,",
   "                                      use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "--annotation_type=<1 (for boxes and segments) or 2 (for image-level labels)>"
  ],
  "consequent": [
   "--annotation_type=<1 (for boxes) or 2 (for image-level labels)>"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   ".SSDMobileNetV1KerasFeatureExtractor("
  ],
  "consequent": [
   "SSDMobileNetV1KerasFeatureExtractor("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_result_rows.extend(",
   "    expansion_generator.expand_boxes_or_segments_from_csv(row, 2))"
  ],
  "consequent": [
   "all_result_rows.extend(expansion_generator.expand_boxes_from_csv(row))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "(selected_indices, num_valid_nms_boxes,"
  ],
  "consequent": [
   "selected_indices, num_valid_nms_boxes = ("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "fields.InputDataFields.groundtruth_label_types: [six.b('APPROPRIATE')],"
  ],
  "consequent": [
   "fields.InputDataFields.groundtruth_label_types: ['APPROPRIATE'],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_masks: uint8 numpy array of shape [num_boxes, height, width]"
  ],
  "consequent": [
   "groundtruth_masks: uint8 numpy array of shape"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "use_keras=False,"
  ],
  "consequent": [
   "use_keras=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "[out_tensor_dict[fields.InputDataFields.image], channels], axis=2)"
  ],
  "consequent": [
   "[tensor_dict[fields.InputDataFields.image], channels], axis=2)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "expected_corloc_per_class = np.array([0, 0, 0], dtype=float)"
  ],
  "consequent": [
   "expected_corloc_per_class = np.array([0, np.divide(0, 0), 0], dtype=float)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "reshaped_detection_features_pool = tf.identity("
  ],
  "consequent": [
   "detection_features = tf.identity("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_classes])"
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.groundtruth_classes])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "# [batch, anchor, depth] -> [depth, batch, anchor]"
  ],
  "consequent": [
   "# [batch, anchor, depth] -> [depth, batch, anchor]",
   "rpn_box_encodings = tf.transpose("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "(boxes_np, scores_np, multiclass_scores_np, classes_np, keypoints_np,"
  ],
  "consequent": [
   "(boxes_np, scores_np, classes_np, keypoints_np, masks_np,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "is_training,",
   "depth_multiplier,",
   "min_depth,",
   "pad_to_multiple,"
  ],
  "consequent": [
   "is_training, depth_multiplier, min_depth, pad_to_multiple,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "use_multiclass_scores: whether to use multiclass scores as class targets"
  ],
  "consequent": [
   "use_multiclass_scores: whether to use multiclass scores as"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return (ssd_mobilenet_v2_fpn_keras_feature_extractor"
  ],
  "consequent": [
   "return (ssd_mobilenet_v2_fpn_keras_feature_extractor."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "num_boxes = tf.shape(feature_grid_y)[1]"
  ],
  "consequent": [
   "assert feature_grid_y.shape[0] == feature_grid_x.shape[0]",
   "assert feature_grid_y.shape[1] == feature_grid_x.shape[1]",
   "num_boxes = feature_grid_y.shape[1].value"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image_height, image_width, depth_multiplier, pad_to_multiple,"
  ],
  "consequent": [
   "image_height, image_width, depth_multiplier, pad_to_multiple)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._metric_prefix +",
   "'PerformanceByCategory/CorLoc@{}IOU/{}'.format("
  ],
  "consequent": [
   "self._metric_prefix + 'PerformanceByCategory/CorLoc@{}IOU/{}'"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self.conv_hyperparams_fn,",
   "use_explicit_padding=use_explicit_padding))"
  ],
  "consequent": [
   "self.conv_hyperparams_fn, use_explicit_padding=use_explicit_padding)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "0.5, 0.6, 0.8, 0.9, 0, None, encoding2"
  ],
  "consequent": [
   "0.5, 0.6, 0.8, 0.9, 0, None, encoding2['counts']"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return (ssd_mobilenet_v1_keras_feature_extractor"
  ],
  "consequent": [
   "return (ssd_mobilenet_v1_keras_feature_extractor."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "size_x = tf.shape(feature_grid_x)[2]"
  ],
  "consequent": [
   "size_x = feature_grid_x.shape[2]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def check_extract_features_returns_correct_shape(self,"
  ],
  "consequent": [
   "def check_extract_features_returns_correct_shape(",
   "    self, batch_size, image_height, image_width, depth_multiplier,",
   "    pad_to_multiple, expected_feature_map_shapes, use_explicit_padding=False,",
   "    use_keras=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for key, average_precision in six.iteritems(average_precisions):"
  ],
  "consequent": [
   "for key, average_precision in average_precisions.iteritems():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "selected_scores, -1*tf.ones(max_selection_size)))"
  ],
  "consequent": [
   "-1 * tf.ones(max_selection_size)))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image_key,",
   "detected_boxes,",
   "detected_scores,",
   "detected_class_labels,"
  ],
  "consequent": [
   "detected_scores, detected_class_labels,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[",
   "    fields.InputDataFields",
   "    .multiclass_scores] = _multiclass_scores_or_one_hot_labels(",
   "        out_tensor_dict[fields.InputDataFields.multiclass_scores],"
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.multiclass_scores], ["
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_returns_correct_shapes_with_min_depth("
  ],
  "consequent": [
   "def test_extract_features_returns_correct_shapes_with_min_depth(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "evaluation."
  ],
  "consequent": [
   "for evaluation."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for relation_field_value, _ in (six.iteritems("
  ],
  "consequent": [
   "for relation_field_value, _ in ("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "fields.InputDataFields.groundtruth_instance_masks] = resized_masks"
  ],
  "consequent": [
   "groundtruth_instance_masks] = resized_masks"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "standard_fields.DetectionResultFields.detection_masks: uint8 numpy array"
  ],
  "consequent": [
   "standard_fields.DetectionResultFields.detection_masks: uint8 numpy"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for variable in variables_helper.get_global_variables_safely():"
  ],
  "consequent": [
   "for variable in tf.global_variables():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/format': dataset_util.bytes_feature(six.b('png')),"
  ],
  "consequent": [
   "'image/format': dataset_util.bytes_feature('png'),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_predictions.loc[all_predictions['ImageID'] == image_id],",
   "class_label_map)"
  ],
  "consequent": [
   "image_predictions, class_label_map)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/key/sha256': dataset_util.bytes_feature(six.b('abc')),"
  ],
  "consequent": [
   "'image/key/sha256': dataset_util.bytes_feature('abc'),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.num_groundtruth_boxes] = tf.shape("
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.num_groundtruth_boxes] = tf.shape("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "matching_iou_threshold: IOU threshold used for matching detected boxes to"
  ],
  "consequent": [
   "matching_iou_threshold: IOU threshold used for matching detected boxes"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "f=tpu_subgraph_predict)"
  ],
  "consequent": [
   "f=tpu_subgraph_first_stage)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "tf.where(valid_nms_boxes_indices,"
  ],
  "consequent": [
   "tf.where(valid_nms_boxes_indx, nms_scores,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for variable in self.variables:"
  ],
  "consequent": [
   "for variable in tf.global_variables():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "reshaped_detection_features_pool = tf.reshape("
  ],
  "consequent": [
   "detection_features = tf.reshape("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "tf.float32 tensor of the same shape as the input with values on the",
   "interval [0, 1]."
  ],
  "consequent": [
   "tf.float32 tensor of shape [batch_size, num_anchors, num_classes] if",
   "background class is not present (else shape is",
   "[batch_size, num_anchors, num_classes + 1]) on the interval [0, 1]."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "[preprocessed_inputs, true_image_shapes])"
  ],
  "consequent": [
   "[preprocessed_inputs])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "initial_dict[key] = set(value_list)"
  ],
  "consequent": [
   "initial_dict[key] = value_list"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_returns_correct_shapes_with_dynamic_inputs("
  ],
  "consequent": [
   "def test_extract_features_returns_correct_shapes_with_dynamic_inputs(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._matching_iou_threshold, category_name))"
  ],
  "consequent": [
   ".format(self._matching_iou_threshold, category_name))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "metrics[expected_metric_name + '_PerformanceByCategory/AP@0.5IOU/dog'],"
  ],
  "consequent": [
   "metrics[",
   "    expected_metric_name + '_PerformanceByCategory/AP@0.5IOU/dog'],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "category_name = unicodedata.normalize('NFKD', category_name)"
  ],
  "consequent": [
   "category_name = unicodedata.normalize("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "initial_dict[key].update(value_list)"
  ],
  "consequent": [
   "initial_dict[key].extend(value_list)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "],"
  ],
  "consequent": [
   "],",
   " [",
   "     'fe58ec1b06db2bb7', mask2.shape[1], mask2.shape[0], '/m/02gy9n',",
   "     encoding2['counts'], 0.6",
   " ]],",
   "columns=[",
   "    'ImageID', 'ImageWidth', 'ImageHeight', 'LabelName', 'Mask', 'Score'",
   "])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self.assertEqual(",
   "    six.b('filename'), tensor_dict[fields.InputDataFields.filename])"
  ],
  "consequent": [
   "self.assertEqual('filename', tensor_dict[fields.InputDataFields.filename])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "\"\"\"Adds a function approximation to calibration proto for a class id.\"\"\""
  ],
  "consequent": [
   "\"\"\"Adds a function approximation to calibration proto for a class label.\"\"\""
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_boxes] = merged_boxes"
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.groundtruth_boxes] = merged_boxes"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_children = set([])"
  ],
  "consequent": [
   "all_children = []"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "correct class within a group-of box are ignored. If weight is > 0, then"
  ],
  "consequent": [
   "correct class within a group-of box are ignored. If weight is > 0"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "args=tpu_subgraph_predict.captured_inputs,"
  ],
  "consequent": [
   "args=tpu_subgraph_first_stage.captured_inputs,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "elif FLAGS.annotation_type != 1:"
  ],
  "consequent": [
   "elif parsed_args.annotation_type != 1:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "masks_np, num_detections_np) = sess.run("
  ],
  "consequent": [
   "num_detections_np) = sess.run("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "# Row header is expected to be the following for boxes:"
  ],
  "consequent": [
   "# Row header is expected to be exactly:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self).__init__(is_training, first_stage_features_stride,",
   "               batch_norm_trainable, reuse_weights, weight_decay)"
  ],
  "consequent": [
   "is_training, first_stage_features_stride, batch_norm_trainable,",
   "reuse_weights, weight_decay)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image = tf.constant(",
   "    list(range(1, 3 * 3 + 1)), dtype=tf.float32, shape=[3, 3, 1])"
  ],
  "consequent": [
   "image = tf.constant(range(1, 3 * 3 + 1), dtype=tf.float32,",
   "                    shape=[3, 3, 1])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "                    use_depthwise=False,",
   "                    num_layers=6,",
   "                    use_keras=False):",
   "kwargs = {}",
   "if use_explicit_padding:",
   "  kwargs.update({'use_explicit_padding': use_explicit_padding})",
   "if use_depthwise:",
   "  kwargs.update({'use_depthwise': use_depthwise})",
   "if num_layers != 6:",
   "  kwargs.update({'num_layers': num_layers})",
   "if use_keras:",
   "  kwargs.update({'use_keras': use_keras})",
   "feature_extractor = self._create_feature_extractor("
  ],
  "consequent": [
   "feature_extractor = self._create_feature_extractor(depth_multiplier,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "segm_rows = [",
   "    '123,cc,b,100,100,0.1,0.2,0.1,0.2,0,MASK',",
   "    '123,cc,d,100,100,0.2,0.3,0.1,0.2,0,MASK',",
   "]",
   "return hierarchy, bbox_rows, segm_rows, label_rows"
  ],
  "consequent": [
   "return hierarchy, bbox_rows, label_rows"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_classes] = merged_classes"
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.groundtruth_classes] = merged_classes"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'from_layer': ['Mixed_4c', 'Mixed_5c', '', '', '', ''"
  ],
  "consequent": [
   "'from_layer': ['Mixed_4c', 'Mixed_5c', '', '', '', ''],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "length = end - start"
  ],
  "consequent": [
   "length = tf.cast(end - start, dtype=tf.float32)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return list(vars_in_ckpt.values())"
  ],
  "consequent": [
   "return vars_in_ckpt.values()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if at least one detection falls within a group-of box with",
   "matching_iou_threshold, weight group_of_weight is added to true",
   "positives. Consequently, if no detection falls within a group-of box,",
   "weight group_of_weight is added to false negatives."
  ],
  "consequent": [
   "(default for Open Images Detection Challenge), then if at least one",
   "detection falls within a group-of box with matching_iou_threshold,",
   "weight group_of_weight is added to true positives. Consequently, if no",
   "detection falls within a group-of box, weight group_of_weight is added",
   "to false negatives."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "              ][:self._num_layers],",
   "'layer_depth': [-1, -1, 512, 256, 256, 128][:self._num_layers],"
  ],
  "consequent": [
   "'layer_depth': [-1, -1, 512, 256, 256, 128],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "box_levels = tf.zeros(tf.shape(boxes)[:2], dtype=tf.int32)"
  ],
  "consequent": [
   "box_levels = tf.zeros(boxes.shape.as_list()[:2], dtype=tf.int32)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "size = [int(image_heights[ind]), int(image_widths[ind])]"
  ],
  "consequent": [
   "size = [int(image_heights.iloc[ind]), int(image_widths[ind])]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "encoding1 = encode_mask(mask1)",
   "encoding2 = encode_mask(mask2)"
  ],
  "consequent": [
   "encoding1 = mask.encode(np.asfortranarray(mask1))",
   "encoding2 = mask.encode(np.asfortranarray(mask2))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if classes[i] in six.viewkeys(category_index):"
  ],
  "consequent": [
   "if classes[i] in category_index.keys():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if (hasattr(tf.image, 'non_max_suppression_with_scores') and",
   "    tf.compat.forward_compatible(2019, 6, 6)):",
   "  (selected_indices, selected_scores",
   "  ) = tf.image.non_max_suppression_with_scores(",
   "      boxlist_and_class_scores.get(),"
  ],
  "consequent": [
   "selected_indices = tf.image.non_max_suppression(",
   "    boxlist_and_class_scores.get(),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class ClassAgnosticNonMaxSuppressionTest(test_case.TestCase,"
  ],
  "consequent": [
   "class ClassAgnosticNonMaxSuppressionTest(test_case.TestCase):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "detections_dict[",
   "    'detection_features'] = self._add_detection_features_output_node("
  ],
  "consequent": [
   "self._add_detection_features_output_node("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_with_dynamic_image_shape(self, use_keras,"
  ],
  "consequent": [
   "def test_extract_features_with_dynamic_image_shape(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "confidence_column_index = -1",
   "labelname_column_index = -1",
   "with open(FLAGS.input_annotations, 'r') as source:"
  ],
  "consequent": [
   "with open(parsed_args.input_annotations, 'r') as source:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict = util_ops.filter_unrecognized_classes(out_tensor_dict)"
  ],
  "consequent": [
   "tensor_dict = util_ops.filter_unrecognized_classes(tensor_dict)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'from_layer': ['Cell_7', 'Cell_11', '', '', '', ''][:self._num_layers],"
  ],
  "consequent": [
   "'from_layer': ['Cell_7', 'Cell_11', '', '', '', ''],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_preprocess_returns_correct_value_range(self, use_keras):"
  ],
  "consequent": [
   "def test_preprocess_returns_correct_value_range(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def clip_to_window(boxlist, window, filter_nonoverlapping=True):"
  ],
  "consequent": [
   "def clip_to_window(boxlist, window):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def add_single_detected_image_info(self,"
  ],
  "consequent": [
   "def add_single_detected_image_info(self, image_key, detected_boxes,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/source_id': dataset_util.bytes_feature("
  ],
  "consequent": [
   "'image/source_id': dataset_util.bytes_feature('image_id')"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if fields.InputDataFields.multiclass_scores in out_tensor_dict:"
  ],
  "consequent": [
   "if fields.InputDataFields.multiclass_scores in tensor_dict:",
   "  tensor_dict[fields.InputDataFields.multiclass_scores] = tf.reshape("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if fields.InputDataFields.groundtruth_confidences in out_tensor_dict:"
  ],
  "consequent": [
   "if fields.InputDataFields.groundtruth_confidences in tensor_dict:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "vals = pd.Series([encoding1, encoding2])"
  ],
  "consequent": [
   "vals = pd.Series([encoding1['counts'], encoding2['counts']])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return self._extract_features("
  ],
  "consequent": [
   "return self._extract_features(image_tensor,",
   "                              depth_multiplier,",
   "                              pad_to_multiple,",
   "                              use_explicit_padding,",
   "                              use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "_ = feature_extractor.extract_features(preprocessed_inputs)"
  ],
  "consequent": [
   "feature_extractor.extract_features(preprocessed_inputs)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if (standard_fields.InputDataFields.groundtruth_difficult in six.viewkeys("
  ],
  "consequent": [
   "if (standard_fields.InputDataFields.groundtruth_difficult in"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [],
  "consequent": [
   "])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "reshaped_detection_features_pool, 'pooled_detection_features')"
  ],
  "consequent": [
   "detection_features, 'detection_features')"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "metrics[expected_metric_name + '_Precision/mAP@0.5IOU'], 0.5)"
  ],
  "consequent": [
   "metrics[",
   "    expected_metric_name + '_Precision/mAP@0.5IOU'],",
   "0.25)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "zero_indexed_groundtruth_classes = out_tensor_dict["
  ],
  "consequent": [
   "zero_indexed_groundtruth_classes = tensor_dict["
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "masks = out_tensor_dict[fields.InputDataFields.groundtruth_instance_masks]"
  ],
  "consequent": [
   "masks = tensor_dict[fields.InputDataFields.groundtruth_instance_masks]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._add_function_approximation_to_calibration_proto("
  ],
  "consequent": [
   "self._add_function_approximation_to_calibration_proto(calibration_config,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.image] = tf.concat("
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.image] = tf.concat("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "_ = feature_extractor(preprocessed_inputs)"
  ],
  "consequent": [
   "feature_extractor(preprocessed_inputs)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "activation_fn: See base class."
  ],
  "consequent": [
   "weight_decay: See base class."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'123,verification,f,0', '123,verification,e,0', '124,verification,d,1',",
   "'124,verification,f,1', '124,verification,c,1'"
  ],
  "consequent": [
   "'123,verification,e,0', '124,verification,d,1', '124,verification,f,1',",
   "'124,verification,c,1'"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_is_difficult_list.astype(dtype=bool)"
  ],
  "consequent": [
   "groundtruth_is_difficult_list.astype(dtype=bool),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "# Two cases will be tested here: using / not using static shapes.",
   "# Named the two test cases for easier control during testing, with a flag of",
   "# '--test_filter=ClassAgnosticNonMaxSuppressionTest.test_batch_classagnostic_nms_with_batch_size_1'",
   "# or",
   "# '--test_filter=ClassAgnosticNonMaxSuppressionTest.test_batch_classagnostic_nms_with_batch_size_1_use_static_shapes'.",
   "@parameterized.named_parameters(('', False), ('_use_static_shapes', True))",
   "def test_batch_classagnostic_nms_with_batch_size_1(self,"
  ],
  "consequent": [
   "def test_batch_classagnostic_nms_with_batch_size_1(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_result_rows.extend(",
   "    expansion_generator.expand_labels_from_csv(row, 2, 3))"
  ],
  "consequent": [
   "all_result_rows.extend(expansion_generator.expand_labels_from_csv(row))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "expanded_lines = expansion_generator.expand_labels_from_csv("
  ],
  "consequent": [
   "expanded_lines = expansion_generator.expand_labels_from_csv(line)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self).__init__('resnet_v1_101', resnet_v1.resnet_v1_101, is_training,"
  ],
  "consequent": [
   "'resnet_v1_101', resnet_v1.resnet_v1_101, is_training,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "tf.transpose(prediction_dict[ANCHORS], perm=[1, 0]),"
  ],
  "consequent": [
   "   anchors = tf.transpose(prediction_dict[ANCHORS], perm=[1, 0])",
   "   return (rpn_box_predictor_features, rpn_features_to_crop,",
   "           prediction_dict['image_shape'], rpn_box_encodings,",
   "           rpn_objectness_predictions_with_background, anchors)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "detections_dict: A dictionary of detection numpy arrays required for"
  ],
  "consequent": [
   "detections_dict: A dictionary of detection numpy arrays required"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "evaluations."
  ],
  "consequent": [
   "for evaluations."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "                                    labelname_column_index=1):",
   "\"\"\"Expands a row containing bounding boxes/segments from CSV file."
  ],
  "consequent": [
   "\"\"\"Expands a row containing bounding boxes from CSV file."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "(2, 5, 5, 32), (2, 3, 3, 32), (2, 2, 2, 32),"
  ],
  "consequent": [
   "(2, 5, 5, 32), (2, 3, 3, 32),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_returns_correct_shapes_with_pad_to_multiple("
  ],
  "consequent": [
   "def test_extract_features_returns_correct_shapes_with_pad_to_multiple(self):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "hierarchy, bbox_rows, _, _ = create_test_data()"
  ],
  "consequent": [
   "hierarchy, bbox_rows, _ = create_test_data()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class DataDecoder(six.with_metaclass(ABCMeta, object)):"
  ],
  "consequent": [
   "class DataDecoder(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "evaluate_masks: If False, evaluation will be performed based on boxes. If"
  ],
  "consequent": [
   "evaluate_masks: If False, evaluation will be performed based on boxes."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "Predictions scores are linearly interpolated based on a class-agnostic"
  ],
  "consequent": [
   "Predictions scores are linearly interpolated based on class-agnostic"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_fused_batchnorm(self, use_keras, use_depthwise):"
  ],
  "consequent": [
   "def test_fused_batchnorm(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.original_image] = tf.cast("
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.original_image] = tf.cast("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "logging.warning('No ground truth instances')"
  ],
  "consequent": [
   "logging.warn('No ground truth instances')"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "`num_boxes` groundtruth boxes of the format [ymin, xmin, ymax, xmax] in",
   "absolute image coordinates."
  ],
  "consequent": [
   "containing `num_boxes` groundtruth boxes of the format",
   "[ymin, xmin, ymax, xmax] in absolute image coordinates."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "standard_fields.InputDataFields.groundtruth_difficult: Optional length M"
  ],
  "consequent": [
   "standard_fields.InputDataFields.groundtruth_difficult: Optional length"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _predict(self, image_features, proposal_boxes, **kwargs):"
  ],
  "consequent": [
   "def _predict(self, image_features, proposal_boxes):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "depth_multiplier,",
   "pad_to_multiple,",
   "scope_name,",
   "use_keras=use_keras,",
   "use_depthwise=use_depthwise)"
  ],
  "consequent": [
   "depth_multiplier, pad_to_multiple, scope_name, use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "numpy boolean array denoting whether a groundtruth box contains a"
  ],
  "consequent": [
   "M numpy boolean array denoting whether a groundtruth box contains a"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class DetectionModel(six.with_metaclass(abc.ABCMeta, _BaseClass)):"
  ],
  "consequent": [
   "class DetectionModel(_BaseClass):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "r\"\"\"An executable to expand image-level labels, boxes and segments."
  ],
  "consequent": [
   "r\"\"\"An executable to expand hierarchically image-level labels and boxes."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "variables_to_ignore_patterns = list([fre for fre in filter_regex_list if fre])"
  ],
  "consequent": [
   "variables_to_ignore_patterns = list(filter(None, filter_regex_list))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "result.append(','.join(split_csv_row))"
  ],
  "consequent": [
   "result.append(','.join(cvs_row_splitted))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'from_layer': ['Mixed_5d', 'Mixed_6e', 'Mixed_7c', '', '', ''"
  ],
  "consequent": [
   "'from_layer': ['Mixed_5d', 'Mixed_6e', 'Mixed_7c', '', '', ''],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if use_keras:",
   "  return (ssd_resnet_v1_fpn_keras_feature_extractor.",
   "          SSDResNet101V1FpnKerasFeatureExtractor(",
   "              is_training=is_training,",
   "              depth_multiplier=depth_multiplier,",
   "              min_depth=min_depth,",
   "              pad_to_multiple=pad_to_multiple,",
   "              conv_hyperparams=self._build_conv_hyperparams(",
   "                  add_batch_norm=False),",
   "              freeze_batchnorm=False,",
   "              inplace_batchnorm_update=False,",
   "              name='ResNet101V1_FPN'))",
   "else:",
   "  return ("
  ],
  "consequent": [
   "return ("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "depth_multiplier,",
   "pad_to_multiple,",
   "use_keras=use_keras,",
   "use_depthwise=use_depthwise)"
  ],
  "consequent": [
   "depth_multiplier, pad_to_multiple, use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class_id):"
  ],
  "consequent": [
   "class_label):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "min_depth=32,"
  ],
  "consequent": [
   "min_depth=32):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "bbox_classes_text = [six.b('cat'), six.b('cheetah')]"
  ],
  "consequent": [
   "bbox_classes_text = ['cat', 'cheetah']"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "                         csv_row,",
   "                         labelname_column_index=1,",
   "                         confidence_column_index=2):",
   "\"\"\"Expands a row containing labels from CSV file."
  ],
  "consequent": [
   "\"\"\"Expands a row containing bounding boxes from CSV file."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "reuse_weights, weight_decay, activation_fn)"
  ],
  "consequent": [
   "reuse_weights, weight_decay)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for key, (value_op, _) in six.iteritems(metric_ops):"
  ],
  "consequent": [
   "for key, (value_op, _) in metric_ops.iteritems():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "2,",
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,",
   "expected_feature_map_shape,",
   "use_explicit_padding=True,"
  ],
  "consequent": [
   "2, image_height, image_width, depth_multiplier, pad_to_multiple,",
   "expected_feature_map_shape, use_explicit_padding=True,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict = util_ops.filter_groundtruth_with_nan_box_coordinates("
  ],
  "consequent": [
   "tensor_dict = util_ops.filter_groundtruth_with_nan_box_coordinates("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "to be returned or not."
  ],
  "consequent": [
   "are to be returned or not."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self,",
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,",
   "use_keras=False,"
  ],
  "consequent": [
   "self, image_height, image_width, depth_multiplier, pad_to_multiple,",
   "use_keras=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "   return np.zeros((segments.shape[0], 1, 1), dtype=np.uint8), np.zeros(",
   "       (segments.shape[0], 4), dtype=np.float32)"
  ],
  "consequent": [
   "size = [1, 1]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "is_training: See base class.",
   "first_stage_features_stride: See base class.",
   "batch_norm_trainable: See base class."
  ],
  "consequent": [
   "is_training: See base class."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "nonzero_area_indices = np.reshape(",
   "    np.nonzero(np.greater(areas, 0.0)), [-1]).astype(np.int32)"
  ],
  "consequent": [
   "nonzero_area_indices = np.reshape(np.nonzero(np.greater(areas, 0.0)),",
   "                                  [-1]).astype(np.int32)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "weight_decay=0.0,"
  ],
  "consequent": [
   "weight_decay=0.0):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "**kwargs))"
  ],
  "consequent": [
   "**self._conv_hyperparams.params(use_bias=use_bias)))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self.assertEqual(",
   "    six.b('image_id'), tensor_dict[fields.InputDataFields.source_id])"
  ],
  "consequent": [
   "self.assertEqual('image_id', tensor_dict[fields.InputDataFields.source_id])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "instead of one-hot encoding of `groundtruth_classes`. When"
  ],
  "consequent": [
   "class targets instead of one-hot encoding of `groundtruth_classes`."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_keyed_child[child].add(hierarchy['LabelName'])"
  ],
  "consequent": [
   "all_keyed_child[child].append(hierarchy['LabelName'])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self, use_keras, use_depthwise):"
  ],
  "consequent": [
   "self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return ("
  ],
  "consequent": [
   "# [b, h, w, c] -> [b, c, h, w]",
   "rpn_box_predictor_features = tf.transpose(",
   "    prediction_dict[RPN_BOX_PREDICTOR_FEATURES], perm=[0, 3, 1, 2])",
   "# [b, h, w, c] -> [b, c, h, w]",
   "rpn_features_to_crop = tf.transpose(",
   "    prediction_dict[RPN_FEATURES_TO_CROP], perm=[0, 3, 1, 2])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_boxes])[0]"
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.groundtruth_boxes])[0]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "provide_groundtruth(detection_model, labels)"
  ],
  "consequent": [
   "_provide_groundtruth(detection_model, labels)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "prediction_dict = detection_model.predict(preprocessed_inputs,"
  ],
  "consequent": [
   "prediction_dict = detection_model._predict_first_stage(preprocessed_inputs)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "segments: pandas Series object containing either"
  ],
  "consequent": [
   "segments: pandas Series object containing either None entries or strings",
   "with COCO-encoded binary masks. All masks are expected to be the same size."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "2,",
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,",
   "expected_feature_map_shape,",
   "use_explicit_padding=False,",
   "use_keras=use_keras,"
  ],
  "consequent": [
   "2, image_height, image_width, depth_multiplier, pad_to_multiple,",
   "expected_feature_map_shape, use_explicit_padding=False,",
   "use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self,",
   "batch_size,",
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,",
   "expected_feature_map_shapes,",
   "use_explicit_padding=False,",
   "num_layers=6,",
   "use_keras=False,"
  ],
  "consequent": [
   "self, batch_size, image_height, image_width, depth_multiplier,",
   "pad_to_multiple, expected_feature_map_shapes, use_explicit_padding=False,",
   "use_keras=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for key, value_list in update.items():"
  ],
  "consequent": [
   "for key, value_list in update.iteritems():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "{",
   "    'use_depthwise': False,",
   "    'use_keras': True",
   "},",
   "{",
   "    'use_depthwise': True,",
   "    'use_keras': True",
   "},",
   "{",
   "    'use_depthwise': False,",
   "    'use_keras': False"
  ],
  "consequent": [
   "{'use_keras': False},",
   "{'use_keras': True},"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "variables_to_restore = variables_helper.get_global_variables_safely()"
  ],
  "consequent": [
   "variables_to_restore = tf.global_variables()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "heights = [tf.shape(feature)[1] for feature in features]"
  ],
  "consequent": [
   "heights = [feature.shape[1].value for feature in features]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "\"\"\"Tests that calibration produces correct class-agnostic values.\"\"\""
  ],
  "consequent": [
   "\"\"\"Ensures that calibration appropriate values, regardless of class.\"\"\""
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/source_id':",
   "    dataset_util.bytes_feature(six.b('image_id')),"
  ],
  "consequent": [
   "'image/source_id': dataset_util.bytes_feature('image_id'),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def get_feature_extractor_variables(self,"
  ],
  "consequent": [
   "def get_feature_extractor_variables(",
   "    self, depth_multiplier, pad_to_multiple, use_keras=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.groundtruth_confidences] = ("
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.groundtruth_confidences] = ("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'layer_depth': [-1, -1, 512, 256, 256, 128][:self._num_layers],"
  ],
  "consequent": [
   "'layer_depth': [-1, -1, 512, 256, 256, 128],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if use_keras:",
   "  return (ssd_resnet_v1_fpn_keras_feature_extractor.",
   "          SSDResNet50V1FpnKerasFeatureExtractor(",
   "              is_training=is_training,",
   "              depth_multiplier=depth_multiplier,",
   "              min_depth=min_depth,",
   "              pad_to_multiple=pad_to_multiple,",
   "              conv_hyperparams=self._build_conv_hyperparams(",
   "                  add_batch_norm=False),",
   "              freeze_batchnorm=False,",
   "              inplace_batchnorm_update=False,",
   "              name='ResNet50V1_FPN'))",
   "else:",
   "  return (",
   "      ssd_resnet_v1_fpn_feature_extractor.SSDResnet50V1FpnFeatureExtractor("
  ],
  "consequent": [
   "return ssd_resnet_v1_fpn_feature_extractor.SSDResnet50V1FpnFeatureExtractor("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "x_y_pair_message = function_approximation.x_y_pair.add()"
  ],
  "consequent": [
   "x_y_pair_message = label_function_approximation.x_y_pair.add()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "batch_size = tf.shape(features)[0]",
   "num_levels = features.get_shape().as_list()[1]",
   "max_feature_height = tf.shape(features)[2]",
   "max_feature_width = tf.shape(features)[3]",
   "num_filters = features.get_shape().as_list()[4]"
  ],
  "consequent": [
   "(batch_size, num_levels, max_feature_height, max_feature_width,",
   " num_filters) = features.get_shape().as_list()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "score_threshold=score_thresh,"
  ],
  "consequent": [
   "score_threshold=score_thresh)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "hierarchy, _, _, label_rows = create_test_data()"
  ],
  "consequent": [
   "hierarchy, _, label_rows = create_test_data()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def check_feature_extractor_variables_under_scope(self,"
  ],
  "consequent": [
   "def check_feature_extractor_variables_under_scope(",
   "    self, depth_multiplier, pad_to_multiple, scope_name, use_keras=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "(2, 1, 1, 32)]"
  ],
  "consequent": [
   "(2, 2, 2, 32), (2, 1, 1, 32)]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "[boxes, scores, multiclass_scores, classes, keypoints, masks,"
  ],
  "consequent": [
   "[boxes, scores, classes, keypoints, masks, num_detections],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "add_type_name, inputs=[reshape_2_pattern, '*'], ordered_inputs=False)"
  ],
  "consequent": [
   "'Add', inputs=[reshape_2_pattern, '*'], ordered_inputs=False)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "# variable.name includes \":0\" at the end, but the names in the",
   "# checkpoint do not have the suffix \":0\". So, we strip it here.",
   "var_name = variable.name[:-2]"
  ],
  "consequent": [
   "var_name = variable.op.name"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "assert split_csv_row[",
   "    labelname_column_index] in self._hierarchy_keyed_parent",
   "child_nodes = self._hierarchy_keyed_parent["
  ],
  "consequent": [
   "assert cvs_row_splited[2] in self._hierarchy_keyed_parent",
   "child_nodes = self._hierarchy_keyed_parent[cvs_row_splited[2]]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "num_detections) = post_processing.batch_multiclass_non_max_suppression("
  ],
  "consequent": [
   ") = post_processing.batch_multiclass_non_max_suppression(",
   "    boxes, scores, score_thresh, iou_thresh,",
   "    max_size_per_class=max_output_size, max_total_size=max_output_size)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "# Row header is expected to be the following for segments:",
   "# ImageID,LabelName,ImageWidth,ImageHeight,XMin,XMax,YMin,YMax,",
   "# IsGroupOf,Mask",
   "split_csv_row = csv_row.split(',')"
  ],
  "consequent": [
   "cvs_row_splitted = csv_row.split(',')",
   "assert len(cvs_row_splitted) == 13"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "* `detection_masks`: (Optional) Outputs float32 tensors of the form"
  ],
  "consequent": [
   "* `detection_masks`: Outputs float32 tensors of the form"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_returns_correct_shapes_256(self, use_keras,"
  ],
  "consequent": [
   "def test_extract_features_returns_correct_shapes_256(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_dict: A dictionary of groundtruth numpy arrays required for"
  ],
  "consequent": [
   "groundtruth_dict: A dictionary of groundtruth numpy arrays required"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "2,",
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,",
   "expected_feature_map_shape,",
   "use_explicit_padding=False,"
  ],
  "consequent": [
   "2, image_height, image_width, depth_multiplier, pad_to_multiple,",
   "expected_feature_map_shape, use_explicit_padding=False,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict)"
  ],
  "consequent": [
   "tensor_dict)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class DetectionEvaluator(six.with_metaclass(ABCMeta, object)):"
  ],
  "consequent": [
   "class DetectionEvaluator(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_children.add(hierarchy['LabelName'])"
  ],
  "consequent": [
   "all_children = [hierarchy['LabelName']] + all_children"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if load_all_detection_checkpoint_vars:"
  ],
  "consequent": [
   "if load_all_detection_checkpoint_vars:",
   "  variables_to_restore[var_name] = variable",
   "else:",
   "  if var_name.startswith(self._extract_features_scope):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "max_width = tf.reduce_max(widths)"
  ],
  "consequent": [
   "max_width = max(widths)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "# ImageID,LabelName,Confidence,XMin,XMax,YMin,YMax,IsGroupOf"
  ],
  "consequent": [
   "# ImageID,Source,LabelName,Confidence,XMin,XMax,YMin,YMax,IsOccluded,",
   "# IsTruncated,IsGroupOf,IsDepiction,IsInside"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "detection_model = INPUT_BUILDER_UTIL_MAP['model_build']("
  ],
  "consequent": [
   "detection_model = model_builder.build("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "max_detections = tf.shape(detection_boxes)[1]"
  ],
  "consequent": [
   "max_detection = tf.shape(detection_boxes)[1]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "pad_to_multiple,"
  ],
  "consequent": [
   "pad_to_multiple)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "Challenge 2018/2019 metrics."
  ],
  "consequent": [
   "Challenge 2018 metric."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "**kwargs))"
  ],
  "consequent": [
   "**conv_hyperparams.params()))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _predict(self, image_features, **kwargs):"
  ],
  "consequent": [
   "def _predict(self, image_features):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "evaluate_corlocs=False):"
  ],
  "consequent": [
   "evaluate_corlocs=False,",
   "group_of_weight=1.0):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return ObjectDetectionEvalMetrics(self.average_precision_per_class, mean_ap,",
   "                                  self.precisions_per_class,",
   "                                  self.recalls_per_class,",
   "                                  self.corloc_per_class, mean_corloc)"
  ],
  "consequent": [
   "return ObjectDetectionEvalMetrics(",
   "    self.average_precision_per_class, mean_ap, self.precisions_per_class,",
   "    self.recalls_per_class, self.corloc_per_class, mean_corloc)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_children.update(children)"
  ],
  "consequent": [
   "all_children.extend(children)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "    soft_nms_sigma=soft_nms_sigma)",
   "num_valid_nms_boxes = tf.shape(selected_indices)[0]"
  ],
  "consequent": [
   "num_valid_nms_boxes = tf.shape(selected_indices)[0]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "app.run(main)"
  ],
  "consequent": [
   "parser = argparse.ArgumentParser(",
   "    description='Hierarchically expand annotations (excluding root node).')",
   "parser.add_argument(",
   "    '--json_hierarchy_file',",
   "    required=True,",
   "    help='Path to the file containing label hierarchy in JSON format.')",
   "parser.add_argument(",
   "    '--input_annotations',",
   "    required=True,",
   "    help=\"\"\"Path to Open Images annotations file (either bounding boxes or",
   "    image-level labels).\"\"\")",
   "parser.add_argument(",
   "    '--output_annotations',",
   "    required=True,",
   "    help=\"\"\"Path to the output file.\"\"\")",
   "parser.add_argument(",
   "    '--annotation_type',",
   "    type=int,",
   "    required=True,",
   "    help=\"\"\"Type of the input annotations: 1 - boxes, 2 - image-level",
   "    labels\"\"\"",
   ")",
   "args = parser.parse_args()",
   "main(args)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_variables_only_created_in_scope(self, use_keras, use_depthwise):"
  ],
  "consequent": [
   "def test_variables_only_created_in_scope(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "tf.ones([1, tf.shape(tensor)[-1]], dtype=tensor.dtype), tensor"
  ],
  "consequent": [
   "tf.ones([1, tensor.shape[-1].value], dtype=tensor.dtype), tensor"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if preprocess_vars_cache is not None:"
  ],
  "consequent": [
   "if (preprocess_vars_cache is not None and"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "refined_box_encodings, class_predictions_with_background, num_proposals,"
  ],
  "consequent": [
   "anchors) = \\"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "max_classes_per_detection=nms_config.max_classes_per_detection,"
  ],
  "consequent": [
   "max_classes_per_detection=nms_config.max_classes_per_detection)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "    depth_multiplier,",
   "    pad_to_multiple,",
   "    use_keras=use_keras,",
   "    use_depthwise=use_depthwise)",
   "expected_variables_len = 274",
   "if use_depthwise:",
   "  expected_variables_len = 278",
   "self.assertEqual(len(variables), expected_variables_len)"
  ],
  "consequent": [
   "    depth_multiplier, pad_to_multiple, use_keras=use_keras)",
   "self.assertEqual(len(variables), 274)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def tpu_subgraph_predict():"
  ],
  "consequent": [
   "def tpu_subgraph_first_stage():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self.assertEqual(six.b('abc'), tensor_dict[fields.InputDataFields.key])"
  ],
  "consequent": [
   "self.assertEqual('abc', tensor_dict[fields.InputDataFields.key])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if six.PY2:",
   "  category_name = category_name.encode('ascii', 'ignore')"
  ],
  "consequent": [
   "'NFKD', category_name).encode('ascii', 'ignore')"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'image/format':",
   "    dataset_util.bytes_feature(six.b('jpeg')),"
  ],
  "consequent": [
   "'image/format': dataset_util.bytes_feature('jpeg'),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "     nms_result.add_field(",
   "         fields.BoxListFields.scores,",
   "         tf.where(valid_nms_boxes_indices,"
  ],
  "consequent": [
   "nms_scores = nms_result.get_field(fields.BoxListFields.scores)",
   "nms_result.add_field(fields.BoxListFields.scores,",
   "                     tf.where(valid_nms_boxes_indx,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if fields.InputDataFields.image_additional_channels in out_tensor_dict:"
  ],
  "consequent": [
   "if fields.InputDataFields.image_additional_channels in tensor_dict:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "last_conv = model_utils.ConvDefs(conv_name='Conv_1', filters=256)"
  ],
  "consequent": [
   "last_conv = mobilenet_v2.ConvDefs(conv_name='Conv_1', filters=256)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "max_total_detections and max_detections_per_class or on negative"
  ],
  "consequent": [
   "max_total_detections and max_detections_per_class."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "groundtruth_confidences = out_tensor_dict["
  ],
  "consequent": [
   "groundtruth_confidences = tensor_dict["
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "category_name = unicodedata.normalize('NFKD', category_name)"
  ],
  "consequent": [
   "category_name = unicodedata.normalize('NFKD', category_name).encode(",
   "    'ascii', 'ignore')"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "max_height = tf.reduce_max(heights)"
  ],
  "consequent": [
   "max_height = max(heights)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "is_training, depth_multiplier, min_depth, pad_to_multiple,"
  ],
  "consequent": [
   "is_training,",
   "depth_multiplier,",
   "min_depth,",
   "pad_to_multiple,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "return (ssd_mobilenet_v2_fpn_feature_extractor"
  ],
  "consequent": [
   "return (ssd_mobilenet_v2_fpn_feature_extractor."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "prediction_stage=2,"
  ],
  "consequent": [
   "prediction_stage=2):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if class_id is not None:",
   "  function_approximation = (",
   "      calibration_proto.class_id_function_approximations",
   "      .class_id_xy_pairs_map[class_id])"
  ],
  "consequent": [
   "if class_label:",
   "  label_function_approximation = (calibration_proto",
   "                                  .label_function_approximations",
   "                                  .label_xy_pairs_map[class_label])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "\"\"\"Add detection features to outputs."
  ],
  "consequent": [
   "\"\"\"Add the detection features to the output node."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "masks; for the None values, zero arrays of size WxH are created. If input"
  ],
  "consequent": [
   "masks; for the None values, zero arrays of size WxH are created. if input"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image_height,",
   "image_width,",
   "depth_multiplier,",
   "pad_to_multiple,"
  ],
  "consequent": [
   "image_height, image_width, depth_multiplier, pad_to_multiple,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def tpu_subgraph_predict_fn(preprocessed_inputs, true_image_shapes):"
  ],
  "consequent": [
   "def tpu_subgraph_first_stage_fn(preprocessed_inputs):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _create_feature_extractor(self,",
   "                              depth_multiplier,",
   "                              pad_to_multiple,",
   "                              use_explicit_padding=False,"
  ],
  "consequent": [
   "def _create_feature_extractor(self, depth_multiplier, pad_to_multiple,",
   "                              use_explicit_padding=False, is_training=False,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "logging.warning("
  ],
  "consequent": [
   "logging.warn("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "score_threshold=score_thresh)"
  ],
  "consequent": [
   "score_threshold=score_thresh,",
   "pad_to_max_output_size=True))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "nmsed_additional_fields,"
  ],
  "consequent": [
   "nmsed_additional_fields, num_detections"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "split_csv_row[labelname_column_index] = parent_node"
  ],
  "consequent": [
   "cvs_row_splitted[2] = parent_node"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def provide_groundtruth(model, labels):"
  ],
  "consequent": [
   "def _provide_groundtruth(model, labels):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if tf.executing_eagerly():",
   "  for variable in self.variables:"
  ],
  "consequent": [
   "for variable in tf.global_variables():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "], 0)"
  ],
  "consequent": [
   "     ], 0)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "1."
  ],
  "consequent": [
   "between 0 and 1."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "split_csv_row[labelname_column_index] = parent_node"
  ],
  "consequent": [
   "cvs_row_splited[2] = parent_node"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if filter_nonoverlapping:",
   "  areas = area(clipped)"
  ],
  "consequent": [
   "areas = area(clipped)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "split_csv_row = csv_row.split(',')"
  ],
  "consequent": [
   "cvs_row_splited = csv_row.split(',')",
   "assert len(cvs_row_splited) == 4"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_variable_count(self, use_keras, use_depthwise):"
  ],
  "consequent": [
   "def test_variable_count(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "widths = [tf.shape(feature)[2] for feature in features]"
  ],
  "consequent": [
   "widths = [feature.shape[2].value for feature in features]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "boxes are difficult."
  ],
  "consequent": [
   "that no boxes are difficult."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "that no boxes are groups-of, it is by default set as None."
  ],
  "consequent": [
   "the case that no boxes are groups-of, it is by default set as None."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[",
   "    fields.InputDataFields.groundtruth_classes] = out_tensor_dict["
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.groundtruth_classes] = tensor_dict["
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "from pycocotools import mask as coco_mask"
  ],
  "consequent": [
   "from pycocotools import mask"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "else:",
   "  out_tensor_dict[fields.InputDataFields.groundtruth_classes] = tf.one_hot(",
   "      zero_indexed_groundtruth_classes, num_classes)",
   "out_tensor_dict.pop(fields.InputDataFields.multiclass_scores, None)"
  ],
  "consequent": [
   "tensor_dict.pop(fields.InputDataFields.multiclass_scores, None)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   ".SSDMobileNetV2FpnFeatureExtractor("
  ],
  "consequent": [
   "SSDMobileNetV2FpnFeatureExtractor("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if fields.InputDataFields.groundtruth_instance_masks in out_tensor_dict:"
  ],
  "consequent": [
   "if fields.InputDataFields.groundtruth_instance_masks in tensor_dict:"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "clipped = gather(clipped, nonzero_area_indices)"
  ],
  "consequent": [
   "return gather(clipped, nonzero_area_indices)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def _create_feature_extractor(self,",
   "                              depth_multiplier,",
   "                              pad_to_multiple,",
   "                              use_explicit_padding=False,"
  ],
  "consequent": [
   "def _create_feature_extractor(self, depth_multiplier, pad_to_multiple,",
   "                              use_explicit_padding=False, use_keras=False):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict["
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields."
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "boxlist_and_class_scores.data['boxes'],",
   "boxlist_and_class_scores.data['scores'],",
   "_) = partitioned_non_max_suppression_padded("
  ],
  "consequent": [
   "tf.image.non_max_suppression_padded("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "   scope_name = self._resnet_scope_name(use_keras)",
   "   self.check_feature_extractor_variables_under_scope(",
   "       depth_multiplier,",
   "       pad_to_multiple,",
   "       scope_name,",
   "       use_keras=use_keras)",
   " def test_variable_count(self, use_keras):",
   "   depth_multiplier = 1",
   "   pad_to_multiple = 1",
   "   variables = self.get_feature_extractor_variables(",
   "       depth_multiplier,",
   "       pad_to_multiple,",
   "       use_keras=use_keras)",
   "   # The number of expected variables in resnet_v1_50, resnet_v1_101,",
   "   # and resnet_v1_152 is 279, 534, and 789 respectively.",
   "   expected_variables_len = 279",
   "   scope_name = self._resnet_scope_name(use_keras)",
   "   if scope_name in ('ResNet101V1_FPN', 'resnet_v1_101'):",
   "     expected_variables_len = 534",
   "   elif scope_name in ('ResNet152V1_FPN', 'resnet_v1_152'):",
   "     expected_variables_len = 789",
   "   self.assertEqual(len(variables), expected_variables_len)"
  ],
  "consequent": [
   "g = tf.Graph()",
   "with g.as_default():",
   "  feature_extractor = self._create_feature_extractor(",
   "      depth_multiplier, pad_to_multiple)",
   "  preprocessed_inputs = tf.placeholder(tf.float32, (4, None, None, 3))",
   "  feature_extractor.extract_features(preprocessed_inputs)",
   "  variables = g.get_collection(tf.GraphKeys.GLOBAL_VARIABLES)",
   "  for variable in variables:",
   "    self.assertTrue(",
   "        variable.name.startswith(self._resnet_scope_name())",
   "        or variable.name.startswith(self._fpn_scope_name()))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "size_y = tf.shape(feature_grid_y)[2]"
  ],
  "consequent": [
   "size_y = feature_grid_y.shape[2]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "for v in variables_helper.get_global_variables_safely():"
  ],
  "consequent": [
   "for v in tf.global_variables():"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "def test_extract_features_returns_correct_shapes_384(self, use_keras,"
  ],
  "consequent": [
   "def test_extract_features_returns_correct_shapes_384(self, use_keras):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "depth_multiplier,",
   "pad_to_multiple,",
   "**kwargs)"
  ],
  "consequent": [
   "                                                     pad_to_multiple,",
   "                                                     use_explicit_padding,",
   "                                                     use_keras=use_keras)",
   "# If the unit test does not support a use_keras arg, it raises an error:",
   "except TypeError:",
   "  feature_extractor = self._create_feature_extractor(depth_multiplier,",
   "                                                     pad_to_multiple,",
   "                                                     use_explicit_padding)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "0.0, 0.3, 0.5, 0.6, 0, None, encoding1"
  ],
  "consequent": [
   "0.0, 0.3, 0.5, 0.6, 0, None, encoding1['counts']"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "dataset_util.bytes_list_feature("
  ],
  "consequent": [
   "dataset_util.bytes_list_feature(['dog', 'cat']),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "feature_extractor = self._create_feature_extractor("
  ],
  "consequent": [
   "feature_extractor = self._create_feature_extractor(depth_multiplier,",
   "                                                   pad_to_multiple,",
   "                                                   use_keras=use_keras)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "_, update_op = metric_ops[next(six.iterkeys(metric_ops))]"
  ],
  "consequent": [
   "_, update_op = metric_ops[metric_ops.keys()[0]]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class EvalMetricOpsVisualization(six.with_metaclass(abc.ABCMeta, object)):"
  ],
  "consequent": [
   "class EvalMetricOpsVisualization(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "(rpn_box_encodings, rpn_objectness_predictions_with_background, anchors,"
  ],
  "consequent": [
   "(rpn_box_predictor_features, rpn_features_to_crop, image_shape,",
   " rpn_box_encodings, rpn_objectness_predictions_with_background,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "compressed_mask = base64.b64decode(segment)",
   "rle_encoded_mask = zlib.decompress(compressed_mask)",
   "decoding_dict = {",
   "    'size': [im_height, im_width],",
   "    'counts': rle_encoded_mask",
   "}",
   "mask_tensor = coco_mask.decode(decoding_dict)"
  ],
  "consequent": [
   "encoding_dict = {'size': [im_height, im_width], 'counts': segment}",
   "mask_tensor = mask.decode(encoding_dict)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "M class labels of object instances in ground truth"
  ],
  "consequent": [
   "representing M class labels of object instances in ground truth"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self._depth, [self._kernel_size, self._kernel_size],"
  ],
  "consequent": [
   "self._depth,",
   "[self._kernel_size, self._kernel_size],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "(selected_indices, num_valid_nms_boxes,"
  ],
  "consequent": [
   "selected_indices, num_valid_nms_boxes = (",
   "    tf.image.non_max_suppression_padded("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "selected_scores = tf.concat(",
   "    [selected_scores,",
   "     tf.zeros(max_selection_size-num_valid_nms_boxes,",
   "              tf.float32)], -1)",
   "nms_result = box_list_ops.gather(boxlist_and_class_scores,"
  ],
  "consequent": [
   "nms_result = box_list_ops.gather(boxlist_and_class_scores,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict[fields.InputDataFields.image] = tf.squeeze("
  ],
  "consequent": [
   "tensor_dict[fields.InputDataFields.image] = tf.squeeze("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "out_tensor_dict = data_augmentation_fn(out_tensor_dict)"
  ],
  "consequent": [
   "tensor_dict = data_augmentation_fn(tensor_dict)"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "group_of_weight: Weight of group-of boxes. If set to 0, detections of the"
  ],
  "consequent": [
   "group_of_weight: weight of a group-of box. If set to 0, detections of the"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "o.type for o in tpu_subgraph_predict.definition.signature.output_arg"
  ],
  "consequent": [
   "for o in tpu_subgraph_first_stage.definition.signature.output_arg"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class Loss(six.with_metaclass(abc.ABCMeta, object)):"
  ],
  "consequent": [
   "class Loss(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "self.assertTrue(any('FusedBatchNorm' in op.type"
  ],
  "consequent": [
   "self.assertTrue(any(op.type == 'FusedBatchNorm'"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "# variable.name includes \":0\" at the end, but the names in the checkpoint",
   "# do not have the suffix \":0\". So, we strip it here.",
   "var_name = variable.name[:-2]"
  ],
  "consequent": [
   "var_name = variable.op.name"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "channels = out_tensor_dict[fields.InputDataFields.image_additional_channels]"
  ],
  "consequent": [
   "channels = tensor_dict[fields.InputDataFields.image_additional_channels]"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class RegionSimilarityCalculator(six.with_metaclass(ABCMeta, object)):"
  ],
  "consequent": [
   "class RegionSimilarityCalculator(object):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "num_boxes = tf.shape(boxes)[1]"
  ],
  "consequent": [
   "_, num_boxes, _ = boxes.get_shape().as_list()"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "x_array, y_array,"
  ],
  "consequent": [
   "x_array,",
   "y_array,"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "proposal_boxes) = tpu_functional.TPUPartitionedCall("
  ],
  "consequent": [
   "tpu_functional.TPUPartitionedCall("
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "class DataToNumpyParser(six.with_metaclass(ABCMeta, object)):",
   "  \"\"\"Abstract interface for data parser that produces numpy arrays.\"\"\""
  ],
  "consequent": [
   "class DataToNumpyParser(object):",
   "  __metaclass__ = ABCMeta"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "[batch_size, max_detections, tf.shape(detection_features_pool)[-1]])"
  ],
  "consequent": [
   "         [batch_size, max_detection, tf.shape(detection_features_pool)[-1]])"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "raise ValueError(",
   "    'detected_boxes, detected_scores and '"
  ],
  "consequent": [
   "raise ValueError('detected_boxes, detected_scores and '"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "all_keyed_child[hierarchy['LabelName']] = set([])"
  ],
  "consequent": [
   "all_keyed_child[hierarchy['LabelName']] = []"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'[%d, %d, %d]' % len(detected_boxes), len(detected_scores),",
   "len(detected_class_labels))"
  ],
  "consequent": [
   "'[%d, %d, %d]' % len(detected_boxes),",
   "len(detected_scores), len(detected_class_labels))"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "dataset_util.bytes_feature(six.b('image_id')),"
  ],
  "consequent": [
   "dataset_util.bytes_feature('image_id'),"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "any('FusedBatchNorm' in op.type"
  ],
  "consequent": [
   "any(op.type == 'FusedBatchNorm'"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "if six.PY2:",
   "  # pylint: disable=deprecated-method",
   "  arg_spec = inspect.getargspec(func)",
   "  # pylint: enable=deprecated-method",
   "else:",
   "  arg_spec = inspect.getfullargspec(func)",
   "if 'preprocess_vars_cache' in arg_spec.args:"
  ],
  "consequent": [
   "'preprocess_vars_cache' in inspect.getargspec(func).args):"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "'', ''][:self._num_layers],"
  ],
  "consequent": [
   "'', ''],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "instance or not. This field is optional to support the case that no"
  ],
  "consequent": [
   "difficult instance or not. This field is optional to support the case"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "depth, [kernel_size, kernel_size],"
  ],
  "consequent": [
   "[kernel_size, kernel_size],"
  ]
 },
 {
  "sha": "fe748d4a4a1576b57c279014ac0ceb47344399c4",
  "author": "pkulzc",
  "created_at": "2019-07-16 01:50:58",
  "condition": [
   "image metrics."
  ],
  "consequent": [
   "per image metrics."
  ]
 },
 {
  "sha": "81123ebf39e2491791b5aa8b4f50d46c10a66223",
  "author": "Toby Boyd",
  "created_at": "2019-07-12 06:35:01",
  "condition": [
   "FLAGS.train_steps = 20000 * 12"
  ],
  "consequent": [
   "FLAGS.train_steps = 400000"
  ]
 },
 {
  "sha": "35620eaf6d13afad531ef384a789e35204bea47d",
  "author": "Toby Boyd",
  "created_at": "2019-07-12 04:46:10",
  "condition": [
   "FLAGS.steps_between_evals = 500"
  ],
  "consequent": [
   "FLAGS.steps_between_evals = 5000"
  ]
 },
 {
  "sha": "35620eaf6d13afad531ef384a789e35204bea47d",
  "author": "Toby Boyd",
  "created_at": "2019-07-12 04:46:10",
  "condition": [
   "FLAGS.batch_size = 2048"
  ],
  "consequent": [
   "FLAGS.batch_size = 4096"
  ]
 },
 {
  "sha": "35620eaf6d13afad531ef384a789e35204bea47d",
  "author": "Toby Boyd",
  "created_at": "2019-07-12 04:46:10",
  "condition": [
   "                  'value': bleu_uncased_best[1],",
   "                  'min_value': bleu_min,",
   "                  'max_value': bleu_max})",
   "  metrics.append({'name': 'bleu_best_score_iteration',",
   "                  'value': bleu_uncased_best[0]})",
   "  metrics.append({'name': 'bleu_uncased_last',",
   "                  'value': stats['bleu_uncased']})",
   "else:",
   "  metrics.append({'name': 'bleu_uncased',",
   "                  'value': stats['bleu_uncased'],"
  ],
  "consequent": [
   "'value': stats['bleu_uncased'],"
  ]
 },
 {
  "sha": "35620eaf6d13afad531ef384a789e35204bea47d",
  "author": "Toby Boyd",
  "created_at": "2019-07-12 04:46:10",
  "condition": [
   "if 'bleu_uncased_history' in stats:",
   "  bleu_uncased_best = max(stats['bleu_uncased_history'],",
   "                          key=lambda x: x[1])",
   "  metrics.append({'name': 'bleu_uncased',"
  ],
  "consequent": [
   "metrics.append({'name': 'bleu_uncased',"
  ]
 },
 {
  "sha": "35620eaf6d13afad531ef384a789e35204bea47d",
  "author": "Toby Boyd",
  "created_at": "2019-07-12 04:46:10",
  "condition": [
   "cased_score_history.append([i, cased_score])",
   "uncased_score_history.append([i, uncased_score])"
  ],
  "consequent": [
   "     print(\"BLEU: uncased={}, cased={}\".format(uncased_score, cased_score))"
  ]
 },
 {
  "sha": "35620eaf6d13afad531ef384a789e35204bea47d",
  "author": "Toby Boyd",
  "created_at": "2019-07-12 04:46:10",
  "condition": [
   "FLAGS.train_steps = 1000"
  ],
  "consequent": [
   "FLAGS.train_steps = 100000"
  ]
 },
 {
  "sha": "fa28535d2940adf24c5e668c4bdba46379286aec",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 15:24:20",
  "condition": [
   "Args:"
  ],
  "consequent": [
   "# Arguments"
  ]
 },
 {
  "sha": "fa28535d2940adf24c5e668c4bdba46379286aec",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 15:24:20",
  "condition": [
   "kernel_size: default 3, the kernel size of middle conv layer at main path"
  ],
  "consequent": [
   "kernel_size: default 3, the kernel size of",
   "    middle conv layer at main path"
  ]
 },
 {
  "sha": "fa28535d2940adf24c5e668c4bdba46379286aec",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 15:24:20",
  "condition": [
   "Returns:"
  ],
  "consequent": [
   "# Returns"
  ]
 },
 {
  "sha": "fa28535d2940adf24c5e668c4bdba46379286aec",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 15:24:20",
  "condition": [
   "x = layers.Dense(classes,",
   "                 activation='softmax',",
   "                 kernel_initializer=initializers.RandomNormal(stddev=0.01),"
  ],
  "consequent": [
   "x = layers.Dense(classes, activation='softmax',",
   "                 # kernel_initializer='he_normal',"
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "self.timestamp_log.append(BatchTimestamp(self.global_steps,"
  ],
  "consequent": [
   "self.timestamp_log.append(BatchTimestamp(batch, timestamp))"
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "self.global_steps += 1",
   "if self.global_steps == 1:"
  ],
  "consequent": [
   "if self.record_batch:",
   "  timestamp = time.time()"
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "self.timestamp_log.append(BatchTimestamp(self.global_steps, timestamp))"
  ],
  "consequent": [
   "if batch != 0:",
   "  self.record_batch = True",
   "  self.timestamp_log.append(BatchTimestamp(batch, timestamp))"
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "\"BenchmarkMetric: {'global step':%d, 'time_taken': %f,\""
  ],
  "consequent": [
   "\"BenchmarkMetric: {'num_batches':%d, 'time_taken': %f,\""
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "self.start_time = time.time()"
  ],
  "consequent": [
   "self.start_time = timestamp",
   "self.record_batch = False",
   "if batch == 0:"
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "(self.global_steps, elapsed_time, examples_per_second))"
  ],
  "consequent": [
   "(batch, elapsed_time, examples_per_second))"
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "# Logs start of step 1 then end of each step based on log_steps interval."
  ],
  "consequent": [
   "# Logs start of step 0 then end of each step based on log_steps interval."
  ]
 },
 {
  "sha": "f4b02d150ebbe62286bc0509cbaa486c492c7d88",
  "author": "Toby Boyd",
  "created_at": "2019-07-11 13:00:39",
  "condition": [
   "\"\"\"Records elapse time of the batch and calculates examples per second.\"\"\"",
   "if self.global_steps % self.log_steps == 0:"
  ],
  "consequent": [
   "if batch % self.log_steps == 0:"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.Conv2D(filters1, kernel_size, strides=strides,"
  ],
  "consequent": [
   "x = tf.keras.layers.Conv2D(filters1, kernel_size, strides=strides,",
   "                           padding='same',"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "kernel_initializer='he_normal',"
  ],
  "consequent": [
   "kernel_initializer='he_normal',",
   "kernel_regularizer="
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "axis=bn_axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON,",
   "name=bn_name_base + '2a')(x, training=training)"
  ],
  "consequent": [
   "name=bn_name_base + '2a',",
   "momentum=BATCH_NORM_DECAY,",
   "epsilon=BATCH_NORM_EPSILON)(",
   "    x, training=training)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.add([x, input_tensor])"
  ],
  "consequent": [
   "x = tf.keras.layers.add([x, input_tensor])"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.Conv2D(filters2, kernel_size,"
  ],
  "consequent": [
   "x = tf.keras.layers.Conv2D(filters2, kernel_size,"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "epsilon=BATCH_NORM_EPSILON,"
  ],
  "consequent": [
   "epsilon=BATCH_NORM_EPSILON)("
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.add([x, shortcut])"
  ],
  "consequent": [
   "x = tf.keras.layers.add([x, shortcut])"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.Activation('relu')(x)"
  ],
  "consequent": [
   "x = tf.keras.layers.Activation('relu')(x)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "padding='valid', use_bias=False,"
  ],
  "consequent": [
   "padding='valid',"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "     parse_record_fn=parse_record_keras,",
   "     datasets_num_private_threads=flags_obj.datasets_num_private_threads,",
   "     dtype=dtype)",
   " eval_input_dataset = None",
   " if not flags_obj.skip_eval:",
   "   eval_input_dataset = input_fn(",
   "       is_training=False,",
   "       data_dir=flags_obj.data_dir,",
   "       batch_size=flags_obj.batch_size,",
   "       num_epochs=flags_obj.train_epochs,",
   "       parse_record_fn=parse_record_keras)"
  ],
  "consequent": [
   "     parse_record_fn=parse_record_keras)",
   " eval_input_dataset = input_fn(",
   "     is_training=False,",
   "     data_dir=flags_obj.data_dir,",
   "     batch_size=flags_obj.batch_size,",
   "     num_epochs=flags_obj.train_epochs,",
   "     parse_record_fn=parse_record_keras)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.BatchNormalization(axis=bn_axis,"
  ],
  "consequent": [
   "x = tf.keras.layers.BatchNormalization(axis=bn_axis, name='bn_conv1',"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.BatchNormalization("
  ],
  "consequent": [
   "x = tf.keras.layers.BatchNormalization(axis=bn_axis,"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.Conv2D(filters1, kernel_size,"
  ],
  "consequent": [
   "x = tf.keras.layers.Conv2D(filters1, kernel_size,"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "# kernel_initializer='he_normal',"
  ],
  "consequent": [
   "kernel_initializer='he_normal',",
   "kernel_regularizer="
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "kernel_regularizer=regularizers.l2(L2_WEIGHT_DECAY),"
  ],
  "consequent": [
   "tf.keras.regularizers.l2(L2_WEIGHT_DECAY),",
   "bias_regularizer=",
   "tf.keras.regularizers.l2(L2_WEIGHT_DECAY),"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "shortcut = layers.BatchNormalization("
  ],
  "consequent": [
   "shortcut = tf.keras.layers.BatchNormalization(",
   "    axis=bn_axis, name=bn_name_base + '1',"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "padding='same', use_bias=False,"
  ],
  "consequent": [
   "padding='same',"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "metrics=(['categorical_accuracy']",
   "         if flags_obj.report_accuracy_metrics else None),",
   "run_eagerly=flags_obj.run_eagerly)"
  ],
  "consequent": [
   "run_eagerly=flags_obj.run_eagerly,",
   "metrics=['categorical_accuracy'])"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "if backend.image_data_format() == 'channels_last':"
  ],
  "consequent": [
   "if tf.keras.backend.image_data_format() == 'channels_last':"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.Conv2D(16, (3, 3),"
  ],
  "consequent": [
   "x = tf.keras.layers.Conv2D(16, (3, 3),"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "axis=bn_axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON,",
   "name=bn_name_base + '2b')(x, training=training)"
  ],
  "consequent": [
   "name=bn_name_base + '2b',",
   "momentum=BATCH_NORM_DECAY,",
   "epsilon=BATCH_NORM_EPSILON)(",
   "    x, training=training)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "name=bn_name_base + '1')(shortcut, training=training)"
  ],
  "consequent": [
   "shortcut, training=training)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "name='bn_conv1',)(x, training=training)"
  ],
  "consequent": [
   "x, training=training)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "                   padding='same', use_bias=False,",
   "                   kernel_initializer='he_normal',",
   "                   kernel_regularizer=regularizers.l2(L2_WEIGHT_DECAY),",
   "                   name=conv_name_base + '2a')(input_tensor)",
   " x = layers.BatchNormalization(",
   "     axis=bn_axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON,",
   "     name=bn_name_base + '2a')(x, training=training)",
   " x = layers.Activation('relu')(x)",
   " x = layers.Conv2D(filters2, kernel_size, padding='same', use_bias=False,",
   "                   kernel_initializer='he_normal',",
   "                   kernel_regularizer=regularizers.l2(L2_WEIGHT_DECAY),",
   "                   name=conv_name_base + '2b')(x)",
   " x = layers.BatchNormalization(",
   "     axis=bn_axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON,",
   "     name=bn_name_base + '2b')(x, training=training)",
   " shortcut = layers.Conv2D(filters2, (1, 1), strides=strides, use_bias=False,",
   "                          kernel_initializer='he_normal',"
  ],
  "consequent": [
   "kernel_initializer='he_normal',",
   "kernel_regularizer="
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "num_gpus=flags_obj.num_gpus,"
  ],
  "consequent": [
   "num_gpus=flags_obj.num_gpus)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "x = layers.ZeroPadding2D(padding=(1, 1), name='conv1_pad')(x)"
  ],
  "consequent": [
   "x = tf.keras.layers.ZeroPadding2D(padding=(1, 1), name='conv1_pad')(x)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "axis=bn_axis, momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON,"
  ],
  "consequent": [
   "momentum=BATCH_NORM_DECAY, epsilon=BATCH_NORM_EPSILON)("
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "name=conv_name_base + '1')(input_tensor)"
  ],
  "consequent": [
   "                            name=conv_name_base + '2a')(input_tensor)",
   " x = tf.keras.layers.BatchNormalization(axis=bn_axis,",
   "                                        name=bn_name_base + '2a',",
   "                                        momentum=BATCH_NORM_DECAY,",
   "                                        epsilon=BATCH_NORM_EPSILON)(",
   "                                            x, training=training)",
   " x = tf.keras.layers.Activation('relu')(x)",
   " x = tf.keras.layers.Conv2D(filters2, kernel_size, padding='same',",
   "                            kernel_initializer='he_normal',",
   "                            kernel_regularizer=",
   "                            tf.keras.regularizers.l2(L2_WEIGHT_DECAY),",
   "                            bias_regularizer=",
   "                            tf.keras.regularizers.l2(L2_WEIGHT_DECAY),",
   "                            name=conv_name_base + '2b')(x)",
   " x = tf.keras.layers.BatchNormalization(axis=bn_axis,",
   "                                        name=bn_name_base + '2b',",
   "                                        momentum=BATCH_NORM_DECAY,",
   "                                        epsilon=BATCH_NORM_EPSILON)(",
   "                                            x, training=training)",
   " shortcut = tf.keras.layers.Conv2D(filters2, (1, 1), strides=strides,",
   "                                   kernel_initializer='he_normal',",
   "                                   kernel_regularizer=",
   "                                   tf.keras.regularizers.l2(L2_WEIGHT_DECAY),",
   "                                   bias_regularizer=",
   "                                   tf.keras.regularizers.l2(L2_WEIGHT_DECAY),",
   "                                   name=conv_name_base + '1')(input_tensor)"
  ]
 },
 {
  "sha": "2ed43e66c4507798c5a3be0f4cc98c57ebb112a2",
  "author": "Haoyu Zhang",
  "created_at": "2019-07-10 08:00:10",
  "condition": [
   "rm_axes = [1, 2] if backend.image_data_format() == 'channels_last' else [2, 3]",
   "x = layers.Lambda(lambda x: backend.mean(x, rm_axes), name='reduce_mean')(x)",
   "x = layers.Dense(classes, activation='softmax',"
  ],
  "consequent": [
   "x = tf.keras.layers.GlobalAveragePooling2D(name='avg_pool')(x)",
   "x = tf.keras.layers.Dense(classes, activation='softmax',"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "optimizer = tf.compat.v1.train.AdamOptimizer(learning_rate=FLAGS.learning_rate)"
  ],
  "consequent": [
   "optimizer = tf.train.AdamOptimizer(learning_rate=FLAGS.learning_rate)"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "as_int = tf.random.uniform("
  ],
  "consequent": [
   "as_int = tf.random_uniform("
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "fc = tf.expand_dims(fc, 2) # 2D"
  ],
  "consequent": [
   "fc = tf.expand_dims(fc, 2)"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "batch_size = tf.compat.v1.placeholder_with_default(FLAGS.batch_size, shape=[])"
  ],
  "consequent": [
   "batch_size = tf.placeholder_with_default(FLAGS.batch_size, shape=[])"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "with tf.compat.v1.Session() as s:"
  ],
  "consequent": [
   "with tf.Session() as s:"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "init = tf.compat.v1.global_variables_initializer()"
  ],
  "consequent": [
   "init = tf.global_variables_initializer()"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "*[w.initializer for w in tf.compat.v1.get_collection('eve')])"
  ],
  "consequent": [
   "*[w.initializer for w in tf.get_collection('eve')])"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "tf.compat.v1.app.run()"
  ],
  "consequent": [
   "tf.app.run()"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "var_list=(tf.compat.v1.get_collection('alice') + tf.compat.v1.get_collection('bob')))"
  ],
  "consequent": [
   "var_list=(tf.get_collection('alice') + tf.get_collection('bob')))"
  ]
 },
 {
  "sha": "2fd76007cf3d51f0a0e92321787a10a5b125b7c4",
  "author": "David Andersen",
  "created_at": "2019-07-10 04:26:39",
  "condition": [
   "self.eve_loss, var_list=tf.compat.v1.get_collection('eve'))"
  ],
  "consequent": [
   "self.eve_loss, var_list=tf.get_collection('eve'))"
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "\"\"\"8 GPU using keras fit/compile with XLA.\"\"\""
  ],
  "consequent": [
   "\"\"\"8 GPU test meant to compare Google implementation",
   "   with MLperf top line submission using the",
   "   hyper-parameters from the winning MLPerf0.5 submission.",
   "   Using similar rules as MLPerf0.5",
   "   Fixed epochs to MLPerf sumbmission's convergnce on 17 epochs",
   "\"\"\""
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "\"\"\"1 GPU using compile/fit without dist_strat.\"\"\""
  ],
  "consequent": [
   "\"\"\"1-GPU MLPerf like test with compile/fit version without dist_strat.\"\"\""
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "def benchmark_1_gpu_ctl_mlperf_like(self):"
  ],
  "consequent": [
   "def benchmark_8_gpu_ctl_mlperf_like(self):",
   "  \"\"\"8 GPU test meant to compare Google implementation."
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "def benchmark_xla_8_gpu_mlperf_like(self):"
  ],
  "consequent": [
   "def benchmark_8_gpu_mlperf_like(self):"
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "#############################################",
   "# Tests below with mlperf in the test name are of two types",
   "#  1) 1 GPU tests are based on MLPerf 0.5 and the TensorFlow pulled submission.",
   "#  2) 8 GPU tests are based on MLPerf 0.5 and use NVIDIA's hyper parameters.",
   "#",
   "# The purpose of both is to get a number to compare to existing results. To do",
   "# this the number of epochs is held constant rather than a race to a given",
   "# accuracy. The accuracy validation is done by the \"early_stop\" tests.",
   "#############################################"
  ],
  "consequent": [
   " def benchmark_1_gpu_ctl_mlperf_like(self):",
   "   \"\"\"1-GPU test to compare Google implementation with MLPerf 0.5.",
   "      Using similar rules as MLPerf 0.5",
   "      - Using Google's convergence hparams as base for 1-GPU test.",
   "      - Fixed the number of epochs to 7, to remove the perf variance.",
   "      - MLPerf submission consistently converges in 7 epochs.",
   "   \"\"\"",
   "   self._setup()",
   "   FLAGS.keras_use_ctl = True",
   "   FLAGS.train_epochs = 7",
   "   self._run_and_report_benchmark()"
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "FLAGS.keras_use_ctl = True",
   "FLAGS.enable_xla = True"
  ],
  "consequent": [
   "FLAGS.keras_use_ctl = True"
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "def benchmark_1_gpu_no_dist_strat_early_stop(self):"
  ],
  "consequent": [
   "def benchmark_1_gpu_no_dist_strat_run_eagerly_early_stop(self):"
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "\"\"\"1 GPU using compile/fit with XLA.\"\"\""
  ],
  "consequent": [
   "\"\"\"1-GPU MLPerf like test with compile/fit version w/xla.\"\"\""
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "\"\"\"1 GPU using keras fit/compile.\"\"\""
  ],
  "consequent": [
   "\"\"\"1-GPU MLPerf like test with compile/fit version.\"\"\""
  ]
 },
 {
  "sha": "18e477c6dabc4b969b3ffd149366510af86ef48a",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 07:48:17",
  "condition": [
   "def benchmark_xla_1_gpu_ctl_mlperf_like(self):",
   "  \"\"\"1 GPU using CTL with XLA.\"\"\""
  ],
  "consequent": [
   "   MLPerf 0.5 top line submission using the",
   "   - hyper-parameters from the winning MLPerf0.5 submission.",
   "   - Using similar rules as MLPerf0.5",
   "   - Fixed epochs to MLPerf submission's convergence on 17 epochs",
   "\"\"\""
  ]
 },
 {
  "sha": "cf1a276a21f02f00cd9e867bcc2c0a521a75a280",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 05:29:10",
  "condition": [
   "grads = neumf_model.sparse_to_dense_grads(",
   "    list(zip(grads, keras_model.trainable_variables)))"
  ],
  "consequent": [
   "grads = neumf_model.sparse_to_dense_grads(list(zip(grads, keras_model.trainable_variables)))"
  ]
 },
 {
  "sha": "cf1a276a21f02f00cd9e867bcc2c0a521a75a280",
  "author": "Toby Boyd",
  "created_at": "2019-07-09 05:29:10",
  "condition": [
   "FLAGS.model_dir = self._get_model_dir('benchmark_8_gpu_fp16')"
  ],
  "consequent": [
   "   FLAGS.model_dir = self._get_model_dir('benchmark_8_gpu')",
   "   self._run_and_report_benchmark(total_batch_size=FLAGS.batch_size,",
   "                                  log_steps=FLAGS.log_steps,",
   "                                  bleu_min=28,",
   "                                  bleu_max=29)",
   " def benchmark_8_gpu_static_batch(self):",
   "   \"\"\"Benchmark 8 gpu.",
   "     Should converge to 28.4 BLEU (uncased). This has not be verified yet.\"",
   "   \"\"\"",
   "   self._setup()",
   "   FLAGS.num_gpus = 8",
   "   FLAGS.data_dir = self.train_data_dir",
   "   FLAGS.vocab_file = self.vocab_file",
   "   # Sets values directly to avoid validation check.",
   "   FLAGS['bleu_source'].value = self.bleu_source",
   "   FLAGS['bleu_ref'].value = self.bleu_ref",
   "   FLAGS.param_set = 'big'",
   "   FLAGS.batch_size = 3072*8",
   "   FLAGS.static_batch = True",
   "   FLAGS.max_length = 64",
   "   FLAGS.train_steps = 400000",
   "   FLAGS.steps_between_evals = 20000",
   "   FLAGS.model_dir = self._get_model_dir('benchmark_8_gpu_static_batch')"
  ]
 },
 {
  "sha": "cad067d8097bbd5b4e091ff862dfe2e076dbe726",
  "author": "Yang Liu",
  "created_at": "2019-07-09 05:28:44",
  "condition": [
   "images, labels = cifar10.inputs(eval_data=FLAGS.eval_data)"
  ],
  "consequent": [
   "eval_data = FLAGS.eval_data == 'test'",
   "images, labels = cifar10.inputs(eval_data=eval_data)"
  ]
 },
 {
  "sha": "ddbf38334a8a2d4e469d72fc4fde22c8b794680e",
  "author": "Yuhao Zhang",
  "created_at": "2019-07-09 02:58:17",
  "condition": [
   "distribution_strategy = distribution_utils.get_distribution_strategy(num_gpus=num_gpus)"
  ],
  "consequent": [
   "distribution_strategy = distribution_utils.get_distribution_strategy(num_gpus)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "movielens.TIMESTAMP_COLUMN: tf.compat.v1.FixedLenFeature([1],"
  ],
  "consequent": [
   "movielens.TIMESTAMP_COLUMN: tf.FixedLenFeature([1], dtype=tf.int64),"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "from official.utils.misc import keras_utils"
  ],
  "consequent": [
   "",
   "tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "movielens.RATING_COLUMN: tf.compat.v1.FixedLenFeature([1],"
  ],
  "consequent": [
   "movielens.RATING_COLUMN: tf.FixedLenFeature([1], dtype=tf.float32),"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "init = [tf.compat.v1.global_variables_initializer(),"
  ],
  "consequent": [
   "init = [tf.global_variables_initializer(),"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "if keras_utils.is_v2_0():",
   "  self.assertEqual(run_info[\"run_parameters\"][2],"
  ],
  "consequent": [
   "self.assertEqual(run_info[\"run_parameters\"][2],"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with self.session(graph=tf.Graph()) as sess:"
  ],
  "consequent": [
   "with self.test_session(graph=tf.Graph()) as sess:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(self.item_csv, \"w\") as f:"
  ],
  "consequent": [
   "with tf.gfile.Open(self.item_csv, \"w\") as f:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "\"\"\"Run tests for MNIST eager loop."
  ],
  "consequent": [
   "\"\"\"Run tests for MNIST eager loop.\"\"\""
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "return 'channels_first' if tfe.context.num_gpus() else 'channels_last'"
  ],
  "consequent": [
   "return \"channels_first\" if tfe.num_gpus() else \"channels_last\""
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with self.session(graph=g) as sess:"
  ],
  "consequent": [
   "with self.test_session(graph=g) as sess:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(self.input_csv, 'w') as temp_csv:"
  ],
  "consequent": [
   "with tf.gfile.Open(self.input_csv, 'w') as temp_csv:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "@unittest.skipIf(bigquery is None, \"Bigquery dependency is not installed.\")"
  ],
  "consequent": [
   "@unittest.skipIf(bigquery is None, 'Bigquery dependency is not installed.')"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "stats = keras_common.build_stats(history, eval_output, [th])"
  ],
  "consequent": [
   "stats = keras_common.build_stats(history, eval_output, th)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with flagsaver.flagsaver(benchmark_log_dir=\"/tmp\"):"
  ],
  "consequent": [
   "with flagsaver.flagsaver(benchmark_log_dir='/tmp'):"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "from tensorflow.python import eager as tfe  # pylint: disable=g-bad-import-order"
  ],
  "consequent": [
   "import tensorflow.contrib.eager as tfe  # pylint: disable=g-bad-import-order"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(temp_file.name, \"w\") as w:"
  ],
  "consequent": [
   "with tf.gfile.Open(temp_file.name, 'w') as w:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)"
  ],
  "consequent": [
   "tf.logging.set_verbosity(tf.logging.ERROR)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(TEST_CSV, 'r') as temp_csv:"
  ],
  "consequent": [
   "with tf.gfile.Open(TEST_CSV, \"r\") as temp_csv:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(",
   "    os.path.join(self.temp_dir, fname), 'w') as test_csv:"
  ],
  "consequent": [
   "with tf.gfile.Open(os.path.join(self.temp_dir, fname), 'w') as test_csv:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "movielens.USER_COLUMN: tf.compat.v1.FixedLenFeature([1], dtype=tf.int64),"
  ],
  "consequent": [
   "movielens.USER_COLUMN: tf.FixedLenFeature([1], dtype=tf.int64),"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "                        \"tf.Tensor(2.0, shape=(), dtype=float32)\"})",
   "else:",
   "  self.assertEqual(run_info[\"run_parameters\"][2],",
   "                   {\"name\": \"random_tensor\", \"string_value\":",
   "                        \"Tensor(\\\"Const:0\\\", shape=(), dtype=float32)\"})"
  ],
  "consequent": [
   "\"Tensor(\\\"Const:0\\\", shape=(), dtype=float32)\"})"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "avg_loss = tf.keras.metrics.Mean('loss', dtype=tf.float32)"
  ],
  "consequent": [
   "avg_loss = tfe.metrics.Mean('loss', dtype=tf.float32)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "if __name__ == \"__main__\":"
  ],
  "consequent": [
   "if __name__ == '__main__':"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with flagsaver.flagsaver(benchmark_logger_type=\"BenchmarkFileLogger\"):"
  ],
  "consequent": [
   "with flagsaver.flagsaver(benchmark_logger_type='BenchmarkFileLogger'):"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(metric_json_file) as f:"
  ],
  "consequent": [
   "with tf.gfile.GFile(metric_json_file) as f:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "accuracy.update_state("
  ],
  "consequent": [
   "accuracy("
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "if __name__ == '__main__':"
  ],
  "consequent": [
   "if __name__ == \"__main__\":"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "                                                         dtype=tf.int64),",
   "movielens.GENRE_COLUMN: tf.compat.v1.FixedLenFeature("
  ],
  "consequent": [
   "movielens.GENRE_COLUMN: tf.FixedLenFeature("
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "tf.io.gfile.makedirs(os.path.join(self.temp_dir, movielens.ML_1M))"
  ],
  "consequent": [
   "tf.gfile.MakeDirs(os.path.join(self.temp_dir, movielens.ML_1M))"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(run_json_file) as f:"
  ],
  "consequent": [
   "with tf.gfile.GFile(run_json_file) as f:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "tf.io.gfile.rmtree(self.get_temp_dir())"
  ],
  "consequent": [
   "tf.gfile.DeleteRecursively(self.get_temp_dir())"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with flagsaver.flagsaver(benchmark_logger_type=\"foo\"):"
  ],
  "consequent": [
   "with flagsaver.flagsaver(benchmark_logger_type='foo'):"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "@unittest.skipIf(keras_utils.is_v2_0(), \"TF 1.0 only test.\")"
  ],
  "consequent": []
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "x = tf.ones([7, tf.cast(tf.sqrt(y), tf.int32), 2, 5])"
  ],
  "consequent": [
   "x = tf.ones([7, tf.to_int32(tf.sqrt(y)), 2, 5])"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "tf.io.gfile.copy(tmpfile.name, self.input_npz)"
  ],
  "consequent": [
   "tf.gfile.Copy(tmpfile.name, self.input_npz)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "self.assertEqual(3, stats['step_timestamp_log'][2].timestamp)"
  ],
  "consequent": [
   "self.assertItemsEqual([1, 2, 3], stats['batch_start_timestamps'])",
   "self.assertItemsEqual([4, 5, 6], stats['batch_end_timestamps'])"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with flagsaver.flagsaver(benchmark_logger_type=\"BaseBenchmarkLogger\"):"
  ],
  "consequent": [
   "with flagsaver.flagsaver(benchmark_logger_type='BaseBenchmarkLogger'):"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "return '/device:GPU:0' if tfe.context.num_gpus() else '/device:CPU:0'"
  ],
  "consequent": [
   "return \"/device:GPU:0\" if tfe.num_gpus() else \"/device:CPU:0\""
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "self.assertEqual(3, len(th.timestamp_log))"
  ],
  "consequent": [
   "   self.assertEqual(3, len(th.batch_start_timestamps))",
   "   self.assertEqual(2, len(th.batch_end_timestamps))",
   "   self.assertEqual(0, th.batch_start_timestamps[0].batch_index)",
   "   self.assertEqual(1, th.batch_start_timestamps[1].batch_index)",
   "   self.assertEqual(4, th.batch_start_timestamps[2].batch_index)",
   "   self.assertEqual(3, th.batch_end_timestamps[0].batch_index)",
   "   self.assertEqual(6, th.batch_end_timestamps[1].batch_index)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "\"\"\"Tests for Model Helper functions.\"\"\""
  ],
  "consequent": [
   "\"\"\" Tests for Model Helper functions.\"\"\""
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "th = keras_utils.TimeHistory(128, 100)"
  ],
  "consequent": [
   "th = keras_common.TimeHistory(128, 100)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with flagsaver.flagsaver(benchmark_logger_type=\"BenchmarkBigQueryLogger\"):"
  ],
  "consequent": [
   "with flagsaver.flagsaver(benchmark_logger_type='BenchmarkBigQueryLogger'):"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "accuracy = tf.keras.metrics.Accuracy('accuracy', dtype=tf.float32)"
  ],
  "consequent": [
   "accuracy = tfe.metrics.Accuracy('accuracy', dtype=tf.float32)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "th = keras_utils.TimeHistory(batch_size=128, log_steps=3)"
  ],
  "consequent": [
   "th = keras_common.TimeHistory(batch_size=128, log_steps=3)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "y = tf.compat.v1.placeholder(dtype=tf.int32, shape=[])"
  ],
  "consequent": [
   "y = tf.placeholder(dtype=tf.int32, shape=[])"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "movielens.ITEM_COLUMN: tf.compat.v1.FixedLenFeature([1], dtype=tf.int64),"
  ],
  "consequent": [
   "movielens.ITEM_COLUMN: tf.FixedLenFeature([1], dtype=tf.int64),"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with tf.io.gfile.GFile(self.ratings_csv, \"w\") as f:"
  ],
  "consequent": [
   "with tf.gfile.Open(self.ratings_csv, \"w\") as f:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "th.timestamp_log = [keras_utils.BatchTimestamp(0, 1),",
   "                    keras_utils.BatchTimestamp(1, 2),",
   "                    keras_utils.BatchTimestamp(2, 3)]"
  ],
  "consequent": [
   "th.batch_start_timestamps = [1, 2, 3]",
   "th.batch_end_timestamps = [4, 5, 6]"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "tf.compat.v1.local_variables_initializer()]"
  ],
  "consequent": [
   "tf.local_variables_initializer()]"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "\"\"\"Run tests for MNIST model."
  ],
  "consequent": [
   "\"\"\"Run tests for MNIST model.\"\"\""
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "avg_loss.update_state(loss(logits, labels))"
  ],
  "consequent": [
   "avg_loss(loss(logits, labels))"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "model.call = tf.function(model.call)"
  ],
  "consequent": [
   "model.call = tfe.defun(model.call)"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with self.session(graph=graph) as sess:"
  ],
  "consequent": [
   "with self.test_session(graph=graph) as sess:"
  ]
 },
 {
  "sha": "4909765543ff0c96627161ecc75eec6c309dbdce",
  "author": "Toby Boyd",
  "created_at": "2019-07-04 01:51:14",
  "condition": [
   "with self.session() as sess:"
  ],
  "consequent": [
   "with self.test_session() as sess:"
  ]
 },
 {
  "sha": "680eb35c45ba7915cb1bc667fb40d9bcee9381c5",
  "author": "Yuefeng Zhou",
  "created_at": "2019-07-03 03:11:33",
  "condition": [
   "if distribution_strategy == \"multi_worker_mirrored\":"
  ],
  "consequent": [
   "if distribution_strategy == \"multi_worker_mirrored\" or num_workers > 1:"
  ]
 },
 {
  "sha": "680eb35c45ba7915cb1bc667fb40d9bcee9381c5",
  "author": "Yuefeng Zhou",
  "created_at": "2019-07-03 03:11:33",
  "condition": [
   "if num_gpus > 1:"
  ],
  "consequent": [
   "if num_gpus > 1 or num_workers > 1:"
  ]
 },
 {
  "sha": "58a3de6c68639c3eac95f7c84089f320d32a85bb",
  "author": "Toby Boyd",
  "created_at": "2019-06-29 04:28:15",
  "condition": [
   "FLAGS.train_steps = 400000"
  ],
  "consequent": [
   "FLAGS.train_steps = 100000"
  ]
 },
 {
  "sha": "58a3de6c68639c3eac95f7c84089f320d32a85bb",
  "author": "Toby Boyd",
  "created_at": "2019-06-29 04:28:15",
  "condition": [
   "FLAGS.steps_between_evals = 20000"
  ],
  "consequent": [
   "FLAGS.steps_between_evals = 5000"
  ]
 },
 {
  "sha": "44ff121d477ed9666f957a2a3a991fd571aba154",
  "author": "nnigania",
  "created_at": "2019-06-29 02:36:37",
  "condition": [
   "def sparse_to_dense_grads(grads_and_vars):"
  ],
  "consequent": [
   "def _sparse_to_dense_grads(grads_and_vars):"
  ]
 },
 {
  "sha": "44ff121d477ed9666f957a2a3a991fd571aba154",
  "author": "nnigania",
  "created_at": "2019-06-29 02:36:37",
  "condition": [
   "# Converting gradients to dense form helps in perf on GPU for NCF",
   "grads = neumf_model.sparse_to_dense_grads(list(zip(grads, keras_model.trainable_variables)))",
   "optimizer.apply_gradients(grads)"
  ],
  "consequent": [
   "optimizer.apply_gradients(list(zip(grads,",
   "                                   keras_model.trainable_variables)))"
  ]
 },
 {
  "sha": "44ff121d477ed9666f957a2a3a991fd571aba154",
  "author": "nnigania",
  "created_at": "2019-06-29 02:36:37",
  "condition": [
   "gradients = sparse_to_dense_grads(gradients)"
  ],
  "consequent": [
   "gradients = _sparse_to_dense_grads(gradients)"
  ]
 },
 {
  "sha": "adc271722e512c8a55ef18b46c666a031de77774",
  "author": "George K",
  "created_at": "2019-06-23 04:24:33",
  "condition": [
   "tf.app.flags.DEFINE_boolean('use_fp16', True,"
  ],
  "consequent": [
   "tf.app.flags.DEFINE_boolean('use_fp16', False,"
  ]
 },
 {
  "sha": "adc271722e512c8a55ef18b46c666a031de77774",
  "author": "George K",
  "created_at": "2019-06-23 04:24:33",
  "condition": [
   "images, labels = cifar10_input.inputs(eval_data=eval_data, batch_size=FLAGS.batch_size)"
  ],
  "consequent": [
   "images, labels = cifar10_input.inputs(eval_data=eval_data,",
   "                                      batch_size=FLAGS.batch_size)"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'--bleu_source={}'.format(self.bleu_source),"
  ],
  "consequent": [
   "\"--bleu_source={}\".format(self.bleu_source),"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "self.vocab_size = misc.get_model_params(FLAGS.param_set, 0)['vocab_size']"
  ],
  "consequent": [
   "self.vocab_size = misc.get_model_params(FLAGS.param_set, 0)[\"vocab_size\"]"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'-model_dir', 'ctl_imagenet_no_dist_strat',"
  ],
  "consequent": [
   "\"-model_dir\", \"ctl_imagenet_no_dist_strat\","
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "_generate_file(self.bleu_source, ['a b', 'c d'])"
  ],
  "consequent": [
   "_generate_file(self.bleu_source, [\"a b\", \"c d\"])"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "f.write('{}\\n'.format(l))"
  ],
  "consequent": [
   "f.write(\"{}\\n\".format(l))"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "self.vocab_file = os.path.join(temp_dir, 'vocab')"
  ],
  "consequent": [
   "self.vocab_file = os.path.join(temp_dir, \"vocab\")"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "self.bleu_ref = os.path.join(temp_dir, 'bleu_ref')"
  ],
  "consequent": [
   "self.bleu_ref = os.path.join(temp_dir, \"bleu_ref\")"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "num_gpus = '2'"
  ],
  "consequent": [
   "num_gpus = \"2\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "_generate_file(self.bleu_ref, ['a b', 'd c'])"
  ],
  "consequent": [
   "_generate_file(self.bleu_ref, [\"a b\", \"d c\"])"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "self._prepare_files_and_flags('--dtype=fp16')"
  ],
  "consequent": [
   "self._prepare_files_and_flags(\"--dtype=fp16\")"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FLAGS.dtype = 'fp32'"
  ],
  "consequent": [
   "FLAGS.dtype = \"fp32\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'-num_gpus', num_gpus,"
  ],
  "consequent": [
   "\"-num_gpus\", num_gpus,"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'--bleu_ref={}'.format(self.bleu_ref),"
  ],
  "consequent": [
   "\"--bleu_ref={}\".format(self.bleu_ref),"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'ignored_program_name',"
  ],
  "consequent": [
   "\"ignored_program_name\","
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FLAGS.param_set = 'base'"
  ],
  "consequent": [
   "FLAGS.param_set = \"base\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FLAGS.param_set = 'tiny'"
  ],
  "consequent": [
   "FLAGS.param_set = \"tiny\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FIXED_TIMESTAMP = 'my_time_stamp'"
  ],
  "consequent": [
   "FIXED_TIMESTAMP = \"my_time_stamp\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FLAGS.distribution_strategy = 'off'"
  ],
  "consequent": [
   "FLAGS.distribution_strategy = \"off\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "with open(filepath, 'w') as f:"
  ],
  "consequent": [
   "with open(filepath, \"w\") as f:"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "if __name__ == '__main__':"
  ],
  "consequent": [
   "if __name__ == \"__main__\":",
   "  misc.define_transformer_flags()"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "WEIGHT_PATTERN = re.compile(r'weights-epoch-.+\\.hdf5')"
  ],
  "consequent": [
   "WEIGHT_PATTERN = re.compile(r\"weights-epoch-.+\\.hdf5\")"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'-distribution_strategy', 'default',"
  ],
  "consequent": [
   "\"-distribution_strategy\", \"default\","
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'-data_format', 'channels_last',"
  ],
  "consequent": [
   "\"-data_format\", \"channels_last\","
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "num_gpus = '0'"
  ],
  "consequent": [
   "num_gpus = \"0\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FLAGS.distribution_strategy = 'one_device'"
  ],
  "consequent": [
   "FLAGS.distribution_strategy = \"one_device\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "self.bleu_source = os.path.join(temp_dir, 'bleu_source')"
  ],
  "consequent": [
   "self.bleu_source = os.path.join(temp_dir, \"bleu_source\")"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FLAGS.distribution_strategy = 'mirrored'"
  ],
  "consequent": [
   "FLAGS.distribution_strategy = \"mirrored\""
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'--vocab_file={}'.format(self.vocab_file),"
  ],
  "consequent": [
   "\"--vocab_file={}\".format(self.vocab_file),"
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'-distribution_strategy', 'off',"
  ],
  "consequent": [
   "\"-distribution_strategy\", \"off\","
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "'-model_dir', 'ctl_imagenet_2_gpu',"
  ],
  "consequent": [
   "\"-model_dir\", \"ctl_imagenet_2_gpu\","
  ]
 },
 {
  "sha": "47a59023ebb4ebdfdfdeefd003ae38ab0a5fac1f",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 22:25:07",
  "condition": [
   "FLAGS.dtype = 'fp16'"
  ],
  "consequent": [
   "FLAGS.dtype = \"fp16\""
  ]
 },
 {
  "sha": "513fdbb258b75755ccbaadae128350052fa69f72",
  "author": "guptapriya",
  "created_at": "2019-06-22 02:47:48",
  "condition": [
   "if params[\"enable_metrics_in_training\"]:",
   "  logits = metrics.MetricLayer(vocab_size)([logits, targets])"
  ],
  "consequent": [
   "logits = metrics.MetricLayer(vocab_size)([logits, targets])"
  ]
 },
 {
  "sha": "0f6845ce513d7be2cbffbf9a0e56b38cbba2fdd7",
  "author": "Neil",
  "created_at": "2019-06-22 02:04:29",
  "condition": [
   "return _help_wrap(text, *args, **kwargs).replace(u\"\\ufeff\", u\"\")"
  ],
  "consequent": [
   "return _help_wrap(text, *args, **kwargs).replace(\"\\ufeff\", \"\")"
  ]
 },
 {
  "sha": "0f6845ce513d7be2cbffbf9a0e56b38cbba2fdd7",
  "author": "Neil",
  "created_at": "2019-06-22 02:04:29",
  "condition": [
   "else:"
  ],
  "consequent": [
   "except LookupError:"
  ]
 },
 {
  "sha": "0f6845ce513d7be2cbffbf9a0e56b38cbba2fdd7",
  "author": "Neil",
  "created_at": "2019-06-22 02:04:29",
  "condition": [
   "def _stdout_utf8():",
   "  try:"
  ],
  "consequent": [
   "try:"
  ]
 },
 {
  "sha": "f21337b1a88559f0866509aaf37bcb19716cd678",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 01:03:22",
  "condition": [
   "\"\"\"Test keras based model w/forced eager and no dist_strat.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test keras based model with forced eager and no dist_strat.\"\"\""
  ]
 },
 {
  "sha": "f21337b1a88559f0866509aaf37bcb19716cd678",
  "author": "Toby Boyd",
  "created_at": "2019-06-22 01:03:22",
  "condition": [
   "\"\"\"Test 1 gpu without distribution strategy and forced eager.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test keras based model with forced eager.\"\"\""
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "- Using similar rules as MLPerf0.5"
  ],
  "consequent": [
   "Using similar rules as MLPerf0.5"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "flag_methods = [imagenet_main.define_imagenet_flags]"
  ],
  "consequent": [
   "flag_methods = [",
   "    lambda: imagenet_main.define_imagenet_flags(dynamic_loss_scale=True,",
   "                                                fp16_implementation=True)",
   "]"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"\"\"1-GPU test to compare Google implementation with MLPerf 0.5."
  ],
  "consequent": [
   "\"\"\"1-GPU test to compare Google implementation with MLperf0.5."
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "      Using similar rules as MLPerf 0.5"
  ],
  "consequent": [
   "Using similar rules as MLPerf0.5"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "if params[\"distribute_strategy\"] or not keras_utils.is_v2_0():"
  ],
  "consequent": [
   "if params[\"distribute_strategy\"] or not ncf_common.is_tf_v2():"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"-batch_size\", \"4\","
  ],
  "consequent": [
   "'-batch_size', '4',"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "keras_utils.set_session_config(enable_eager=flags_obj.enable_eager,"
  ],
  "consequent": [
   "keras_utils.set_session_config(enable_eager=flags_obj.enable_eager)"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "def define_keras_flags(dynamic_loss_scale=True):"
  ],
  "consequent": [
   "def define_keras_flags():"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "tf_data_experimental_slack=True)"
  ],
  "consequent": [
   "tf_data_experimental_slack=True,",
   "enable_xla=enable_xla)"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "flags_core.define_base(export_dir=False, run_eagerly=True)"
  ],
  "consequent": [
   "flags_core.define_base(export_dir=False)"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "distribution_strategy=True, run_eagerly=False):"
  ],
  "consequent": [
   "distribution_strategy=True):"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"\"\""
  ],
  "consequent": [
   "'''"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"\"\"1-GPU MLPerf like test with compile/fit version.\"\"\""
  ],
  "consequent": [
   "\"\"\"1-GPU MLPerf like test with compile/fit version\"\"\""
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "not keras_utils.is_v2_0() or strategy is None)):"
  ],
  "consequent": [
   "not ncf_common.is_tf_v2() or strategy is None)):"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"\"\"8 GPU test meant to compare Google implementation."
  ],
  "consequent": [
   "\"\"\"8 GPU test meant to compare Google implementation"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "imagenet_main.NUM_IMAGES[\"validation\"] = 4"
  ],
  "consequent": [
   "imagenet_main.NUM_IMAGES['validation'] = 4"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "- Using Google's convergence hparams as base for 1-GPU test."
  ],
  "consequent": [
   "Using Google's convergence hparams as base for 1-GPU test."
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "keras_model.compile(optimizer=optimizer,"
  ],
  "consequent": [
   "keras_model.compile(optimizer=optimizer)"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "define_imagenet_flags()"
  ],
  "consequent": [
   "define_imagenet_flags(dynamic_loss_scale=True, fp16_implementation=True)"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "define_cifar_flags()"
  ],
  "consequent": [
   "cifar_main.define_cifar_flags()",
   "keras_common.define_keras_flags()"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "def define_imagenet_flags():"
  ],
  "consequent": [
   "def define_imagenet_flags(dynamic_loss_scale=False,",
   "                          fp16_implementation=False,",
   "                          enable_xla=False):"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"\"\"Convert the logits returned by the base model to softmax logits."
  ],
  "consequent": [
   "'''Convert the logits returned by the base model to softmax logits."
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "dynamic_loss_scale=True,",
   "fp16_implementation=True)"
  ],
  "consequent": [
   "dynamic_loss_scale=dynamic_loss_scale,",
   "fp16_implementation=fp16_implementation,",
   "enable_xla=enable_xla)"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "cifar10_main.NUM_IMAGES[\"validation\"] = 4"
  ],
  "consequent": [
   "cifar10_main.NUM_IMAGES['validation'] = 4"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "- hyper-parameters from the winning MLPerf0.5 submission."
  ],
  "consequent": [
   "hyper-parameters from the winning MLPerf0.5 submission."
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "This is needed because:"
  ],
  "consequent": [
   "This is needed becasue:"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "keras_cifar_main.define_cifar_flags()"
  ],
  "consequent": [
   "cifar10_main.define_cifar_flags()",
   "keras_common.define_keras_flags()"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "- MLPerf submission consistently converges in 7 epochs."
  ],
  "consequent": [
   "MLPerf submission consistently converges in 7 epochs."
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"\"\"NCF with custom training loop. Works only in TF 2.0.\"\"\""
  ],
  "consequent": [
   "   self._setup()",
   "   FLAGS.keras_use_ctl = True",
   "   FLAGS.num_gpus = 2",
   "   self._run_and_report_benchmark()",
   " # NCF with custom training loop. Works only in TF 2.0"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "fp16_implementation=False):"
  ],
  "consequent": [
   "fp16_implementation=False, enable_xla=False):"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "- Fixed the number of epochs to 7, to remove the perf variance."
  ],
  "consequent": [
   "Fixed the number of epochs to 7, to remove the perf variance."
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"-use_synthetic_data\", \"true\""
  ],
  "consequent": [
   "'-use_synthetic_data', 'true'"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "- Fixed epochs to MLPerf submission's convergence on 17 epochs"
  ],
  "consequent": [
   "Fixed epochs to MLPerf sumbmission's convergnce on 17 epochs"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "flag_methods = [keras_cifar_main.define_cifar_flags]"
  ],
  "consequent": [
   "flag_methods = [",
   "    keras_common.define_keras_flags, cifar_main.define_cifar_flags",
   "]"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "      MLPerf 0.5 top line submission using the"
  ],
  "consequent": [
   "with MLperf top line submission using the"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "\"-train_steps\", \"1\","
  ],
  "consequent": [
   "'-train_steps', '1',"
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   " Args:",
   "   logits: used to create softmax.",
   " Returns:",
   "   Softmax with the first column of zeros is equivalent to sigmoid."
  ],
  "consequent": [
   "Softmax with the first column of zeros is equivalent to sigmoid."
  ]
 },
 {
  "sha": "a68f65f8b06969ee314354e3692fce10be7712c7",
  "author": "Toby Boyd",
  "created_at": "2019-06-21 23:22:10",
  "condition": [
   "all_reduce_alg=False,"
  ],
  "consequent": [
   "all_reduce_alg=False"
  ]
 },
 {
  "sha": "adc8f11bfe595b840d242d4bd214b85148a4dac3",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-21 06:57:37",
  "condition": [
   "keras_imagenet_main.define_imagenet_keras_flags()"
  ],
  "consequent": [
   "imagenet_main.define_imagenet_flags()",
   "keras_common.define_keras_flags()"
  ]
 },
 {
  "sha": "092def7b4b4a49cc5d2583d1265c37227ed27fea",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-21 06:19:06",
  "condition": [
   "config = keras_utils.get_config_proto_v1()"
  ],
  "consequent": [
   "config = keras_common.get_config_proto_v1()"
  ]
 },
 {
  "sha": "018ab4b5fdf782ffe3a28b90fe3e2c377f56016e",
  "author": "Igor",
  "created_at": "2019-06-21 04:39:21",
  "condition": [
   "FLAGS.train_steps = 400000"
  ],
  "consequent": [
   "FLAGS.train_steps = 100000"
  ]
 },
 {
  "sha": "018ab4b5fdf782ffe3a28b90fe3e2c377f56016e",
  "author": "Igor",
  "created_at": "2019-06-21 04:39:21",
  "condition": [
   "FLAGS.steps_between_evals = 20000"
  ],
  "consequent": [
   "FLAGS.steps_between_evals = 5000"
  ]
 },
 {
  "sha": "cf3c240728d9a4cf3c5fe6a5cf49d199c6b0a4be",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-21 02:54:58",
  "condition": [
   "if flags_obj.set_learning_phase_to_train:",
   "  # TODO(haoyuzhang): Understand slowdown of setting learning phase when",
   "  # not using distribution strategy.",
   "  tf.keras.backend.set_learning_phase(1)"
  ],
  "consequent": [
   "tf.keras.backend.set_learning_phase(1)"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "def get_decoder_self_attention_bias(length, dtype=tf.float32):"
  ],
  "consequent": [
   "def get_decoder_self_attention_bias(length):"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "return tf.cast(tf.equal(x, padding_value), dtype)"
  ],
  "consequent": [
   "return tf.cast(tf.equal(x, padding_value), tf.float32)"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "decoder_bias = neg_inf * (1.0 - valid_locs)"
  ],
  "consequent": [
   "decoder_bias = _NEG_INF * (1.0 - valid_locs)"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "def get_padding(x, padding_value=0, dtype=tf.float32):"
  ],
  "consequent": [
   "def get_padding(x, padding_value=0):"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "v = tf.concat([tf.cast(cache[\"v\"], k.dtype), v], axis=1)"
  ],
  "consequent": [
   "v = tf.concat([cache[\"v\"], v], axis=1)"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "return tf.cast(norm_x * self.scale + self.bias, input_dtype)"
  ],
  "consequent": [
   "return norm_x * self.scale + self.bias"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "weights = _float32_softmax(logits, name=\"attention_weights\")"
  ],
  "consequent": [
   "weights = tf.nn.softmax(logits, name=\"attention_weights\")"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "length, dtype=self.params['dtype'])"
  ],
  "consequent": [
   "length)"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "# Very low numbers to represent -infinity. We do not actually use -Inf, since we",
   "# want to be able to multiply these values by zero to get zero. (-Inf * 0 = NaN)",
   "_NEG_INF_FP32 = -1e9"
  ],
  "consequent": [
   "_NEG_INF = -1e9"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "attention_bias = padding * _NEG_INF_FP32"
  ],
  "consequent": [
   "attention_bias = padding * _NEG_INF"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "dtype=True,"
  ],
  "consequent": [
   "dtype=False,"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "valid_locs = tf.linalg.band_part(tf.ones([length, length], dtype=dtype),"
  ],
  "consequent": [
   "valid_locs = tf.linalg.band_part(tf.ones([length, length]), -1, 0)"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "initializer=tf.zeros_initializer(),"
  ],
  "consequent": [
   "initializer=tf.zeros_initializer())"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "k = tf.concat([tf.cast(cache[\"k\"], k.dtype), k], axis=1)"
  ],
  "consequent": [
   "k = tf.concat([cache[\"k\"], k], axis=1)"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "initializer=tf.ones_initializer(),"
  ],
  "consequent": [
   "initializer=tf.ones_initializer())"
  ]
 },
 {
  "sha": "f8ec01aec2535993881b018a84be4545ea64e7a7",
  "author": "Reed",
  "created_at": "2019-06-20 07:49:49",
  "condition": [
   "pos_encoding = model_utils.get_position_encoding("
  ],
  "consequent": [
   "decoder_inputs += model_utils.get_position_encoding("
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "tf_data_experimental_slack=False, enable_xla=False):"
  ],
  "consequent": [
   "tf_data_experimental_slack=False):"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "keras_utils.set_session_config(",
   "    enable_eager=flags_obj.enable_eager,",
   "    enable_xla=flags_obj.enable_xla,",
   "    enable_grappler_layout_optimizer=",
   "    flags_obj.enable_grappler_layout_optimizer)"
  ],
  "consequent": [
   "# TODO(tobyboyd): Remove eager flag when tf 1.0 testing ends.",
   "# Eager is default in tf 2.0 and should not be toggled",
   "if keras_common.is_v2_0():",
   "  keras_common.set_config_v2()",
   "else:",
   "  config = keras_common.get_config_proto_v1()",
   "  if flags_obj.enable_eager:",
   "    tf.compat.v1.enable_eager_execution(config=config)",
   "  else:",
   "    sess = tf.Session(config=config)",
   "    tf.keras.backend.set_session(sess)"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "wall_time=wall_time_sec,"
  ],
  "consequent": [
   "wall_time=wall_time_sec,",
   "metrics=metrics)"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "optimizer = (",
   "    tf.compat.v1.train.experimental.enable_mixed_precision_graph_rewrite("
  ],
  "consequent": [
   "optimizer = tf.compat.v1.train.experimental.enable_mixed_precision_graph_rewrite("
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "tf_data_experimental_slack=True,"
  ],
  "consequent": [
   "tf_data_experimental_slack=True)"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "all_reduce_alg=True,"
  ],
  "consequent": [
   "all_reduce_alg=True"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "    Note: Spatial Persistent mode may lead to accuracy losses for certain"
  ],
  "consequent": [
   "persistent mode may lead to accuracy losses for certain models.\"\"\""
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "optimizer, loss_scale=loss_scale))"
  ],
  "consequent": [
   "optimizer, loss_scale=loss_scale)"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "fp16_implementation=fp16_implementation,"
  ],
  "consequent": [
   "fp16_implementation=fp16_implementation)"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "keras_utils.set_session_config(enable_eager=flags_obj.enable_eager)"
  ],
  "consequent": [
   "# TODO(tobyboyd): Remove eager flag when tf 1.0 testing ends.",
   "# Eager is default in tf 2.0 and should not be toggled",
   "if keras_common.is_v2_0():",
   "  keras_common.set_config_v2()",
   "else:",
   "  config = keras_common.get_config_proto_v1()",
   "  if flags_obj.enable_eager:",
   "    tf.compat.v1.enable_eager_execution(config=config)",
   "  else:",
   "    sess = tf.Session(config=config)",
   "    tf.keras.backend.set_session(sess)"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "   flag_methods = [keras_imagenet_main.define_imagenet_keras_flags]"
  ],
  "consequent": [
   "flag_methods = [",
   "    keras_common.define_keras_flags,",
   "    lambda: imagenet_main.define_imagenet_flags(dynamic_loss_scale=True)",
   "]"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "define_imagenet_keras_flags()"
  ],
  "consequent": [
   "imagenet_main.define_imagenet_flags(dynamic_loss_scale=True)",
   "keras_common.define_keras_flags()"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "\"\"\"Set CuDNN batchnorm mode for better performance."
  ],
  "consequent": [
   "\"\"\"Set CuDNN batchnorm mode for better performance. Note that the spatial"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "   flags_str = flags_core.get_nondefault_flags_as_str()",
   "   self.report_benchmark(iters=eval_results['global_step'],"
  ],
  "consequent": [
   "self.report_benchmark(",
   "    iters=eval_results['global_step'],"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "flag_methods = [keras_imagenet_main.define_imagenet_keras_flags]"
  ],
  "consequent": [
   "flag_methods = [",
   "    keras_common.define_keras_flags,",
   "    lambda: imagenet_main.define_imagenet_flags(dynamic_loss_scale=True)",
   "]"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "fp16_implementation=False, enable_xla=False):"
  ],
  "consequent": [
   "fp16_implementation=False):"
  ]
 },
 {
  "sha": "269581dc231192d2a19f5fa54821b3bc6a104292",
  "author": "Toby Boyd",
  "created_at": "2019-06-20 05:48:55",
  "condition": [
   "def define_imagenet_flags(dynamic_loss_scale=False,"
  ],
  "consequent": [
   "def define_imagenet_flags(dynamic_loss_scale=False, fp16_implementation=False):"
  ]
 },
 {
  "sha": "1e527fb5ce7b8bcfcb5d07891f60824d042a973c",
  "author": "anj-s",
  "created_at": "2019-06-20 05:14:59",
  "condition": [
   "flags_str = flags_core.get_nondefault_flags_as_str()",
   "self.report_benchmark(iters=-1, wall_time=wall_time_sec, metrics=metrics,"
  ],
  "consequent": [
   "self.report_benchmark(iters=-1, wall_time=wall_time_sec, metrics=metrics)"
  ]
 },
 {
  "sha": "d361076952b73706c5c7ddf9c940bf42c27a3213",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 23:06:08",
  "condition": [
   "super(KerasBenchmark, self).__init__(",
   "    output_dir=output_dir,"
  ],
  "consequent": [
   "self.output_dir = output_dir"
  ]
 },
 {
  "sha": "d361076952b73706c5c7ddf9c940bf42c27a3213",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 23:06:08",
  "condition": [
   "class KerasBenchmark(PerfZeroBenchmark):"
  ],
  "consequent": [
   "class KerasBenchmark(tf.test.Benchmark):"
  ]
 },
 {
  "sha": "d361076952b73706c5c7ddf9c940bf42c27a3213",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 23:06:08",
  "condition": [
   "default_flags=default_flags,"
  ],
  "consequent": [
   "self.default_flags = default_flags or {}"
  ]
 },
 {
  "sha": "d361076952b73706c5c7ddf9c940bf42c27a3213",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 23:06:08",
  "condition": [
   "flag_methods=flag_methods)"
  ],
  "consequent": [
   "   self.flag_methods = flag_methods or {}",
   "   if not output_dir:",
   "     self.output_dir = '/tmp/'",
   " def _get_model_dir(self, folder_name):",
   "   return os.path.join(self.output_dir, folder_name)",
   " def _setup(self):",
   "   \"\"\"Sets up and resets flags before each test.\"\"\"",
   "   tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.DEBUG)",
   "   if KerasBenchmark.local_flags is None:",
   "     for flag_method in self.flag_methods:",
   "       flag_method()",
   "     # Loads flags to get defaults to then override. List cannot be empty.",
   "     flags.FLAGS(['foo'])",
   "     # Overrides flag values with defaults for the class of tests.",
   "     for k, v in self.default_flags.items():",
   "       setattr(FLAGS, k, v)",
   "     saved_flag_values = flagsaver.save_flag_values()",
   "     KerasBenchmark.local_flags = saved_flag_values",
   "   else:",
   "     flagsaver.restore_flag_values(KerasBenchmark.local_flags)"
  ]
 },
 {
  "sha": "d361076952b73706c5c7ddf9c940bf42c27a3213",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 23:06:08",
  "condition": [
   "from official.utils.flags import core as flags_core",
   "from official.utils.testing.perfzero_benchmark import PerfZeroBenchmark"
  ],
  "consequent": [
   "import os",
   "",
   "from absl import flags",
   "from absl.testing import flagsaver",
   "import tensorflow as tf  # pylint: disable=g-bad-import-order",
   "",
   "FLAGS = flags.FLAGS"
  ]
 },
 {
  "sha": "d361076952b73706c5c7ddf9c940bf42c27a3213",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 23:06:08",
  "condition": [
   "flags_str = flags_core.get_nondefault_flags_as_str()",
   "self.report_benchmark(",
   "    iters=-1,",
   "    wall_time=wall_time_sec,",
   "    metrics=metrics,",
   "    extras={'flags': flags_str})"
  ],
  "consequent": [
   "   self.report_benchmark(iters=-1, wall_time=wall_time_sec, metrics=metrics)"
  ]
 },
 {
  "sha": "d62ddcaa8f6cb6809acf89e549109079d8c010c6",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 13:00:18",
  "condition": [
   "metrics=metrics,"
  ],
  "consequent": [
   "metrics=metrics)"
  ]
 },
 {
  "sha": "d62ddcaa8f6cb6809acf89e549109079d8c010c6",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 13:00:18",
  "condition": [
   "flags_str = flags_core.get_nondefault_flags_as_str()"
  ],
  "consequent": []
 },
 {
  "sha": "01c3a4f3f34c2636d4108be35df31ac5f240a23b",
  "author": "Toby Boyd",
  "created_at": "2019-06-19 06:04:06",
  "condition": [
   "name='train_steps', short_name='ts', default=300000,"
  ],
  "consequent": [
   "name='train_steps', short_name='ts', default=None,"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "super(NCFKerasSynth, self).__init__("
  ],
  "consequent": [
   "super(KerasNCFSyntheticData, self).__init__("
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "# if cache_age > rconst.CACHE_INVALIDATION_SEC:"
  ],
  "consequent": [
   "if cache_age > rconst.CACHE_INVALIDATION_SEC:"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "flagsaver.restore_flag_values(NCFKerasBenchmarkBase.local_flags)"
  ],
  "consequent": [
   "flagsaver.restore_flag_values(KerasNCFBenchmarkBase.local_flags)"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "super(NCFKerasAccuracy, self).__init__("
  ],
  "consequent": [
   "super(KerasNCFRealData, self).__init__("
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "  def benchmark_1_gpu_mlperf_like(self):",
   "    \"\"\"1-GPU MLPerf like test with compile/fit version\"\"\"",
   "    self._setup()",
   "    FLAGS.train_epochs = 7",
   "    self._run_and_report_benchmark()",
   "",
   "  def benchmark_8_gpu_ctl_mlperf_like(self):",
   "    \"\"\"8 GPU test meant to compare Google implementation",
   "       with MLperf top line submission using the",
   "       hyper-parameters from the winning MLPerf0.5 submission.",
   "       Using similar rules as MLPerf0.5",
   "       Fixed epochs to MLPerf sumbmission's convergnce on 17 epochs",
   "    \"\"\"",
   "    self._setup()",
   "    FLAGS.keras_use_ctl = True",
   "    FLAGS.num_gpus = 8",
   "    FLAGS.train_epochs = 17",
   "    FLAGS.batch_size = 1048576",
   "    FLAGS.learning_rate = 0.0045",
   "    FLAGS.beta1 = 0.25",
   "    FLAGS.beta2 = 0.5",
   "    FLAGS.epsilon = 1e-8",
   "    self._run_and_report_benchmark()",
   "",
   "class NCFKerasSynth(NCFKerasBenchmarkBase):"
  ],
  "consequent": [
   "class KerasNCFSyntheticData(KerasNCFBenchmarkBase):"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "NCFKerasBenchmarkBase.local_flags = saved_flag_values"
  ],
  "consequent": [
   "KerasNCFBenchmarkBase.local_flags = saved_flag_values"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "if NCFKerasBenchmarkBase.local_flags is None:"
  ],
  "consequent": [
   "if KerasNCFBenchmarkBase.local_flags is None:"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "class NCFKerasAccuracy(NCFKerasBenchmarkBase):"
  ],
  "consequent": [
   "class KerasNCFRealData(KerasNCFBenchmarkBase):"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "#   valid_cache = False"
  ],
  "consequent": [
   "valid_cache = False"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "# (nnigania)disabled this check as the dataset is not expected to change",
   "# cache_age = time.time() - cached_data.get(\"create_time\", 0)"
  ],
  "consequent": [
   "cache_age = time.time() - cached_data.get(\"create_time\", 0)"
  ]
 },
 {
  "sha": "90f8c43b8b8fd50b7f31ec5dff8dca995eab5e97",
  "author": "nnigania",
  "created_at": "2019-06-19 05:44:54",
  "condition": [
   "class NCFKerasBenchmarkBase(tf.test.Benchmark):"
  ],
  "consequent": [
   "class KerasNCFBenchmarkBase(tf.test.Benchmark):"
  ]
 },
 {
  "sha": "d44b7283cbf27d7b68153fda00058c76e7ccd064",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 04:02:52",
  "condition": [
   "datasets_num_private_threads=datasets_num_private_threads"
  ],
  "consequent": [
   "datasets_num_private_threads=datasets_num_private_threads,",
   "num_parallel_batches=num_parallel_batches"
  ]
 },
 {
  "sha": "d44b7283cbf27d7b68153fda00058c76e7ccd064",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 04:02:52",
  "condition": [
   "Returns:",
   "   Dict of results of the run.  Contains the keys `eval_results` and"
  ],
  "consequent": [
   "Dict of results of the run.  Contains the keys `eval_results` and"
  ]
 },
 {
  "sha": "d44b7283cbf27d7b68153fda00058c76e7ccd064",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 04:02:52",
  "condition": [
   "optimizer = tf.compat.v1.train.experimental.enable_mixed_precision_graph_rewrite("
  ],
  "consequent": [
   "optimizer = tf.train.experimental.enable_mixed_precision_graph_rewrite("
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test trivial Keras model in legacy graph mode with 8 GPUs.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test trivial Keras model (input pipeline) in legacy graph mode with 8",
   "   GPUs.",
   "\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test Keras model in legacy graph tuning, XLA_FP16, 8 GPUs and fp16.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model in legacy graph mode with manual config tuning, XLA,",
   "   8 GPUs and fp16.",
   "\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test trivial Keras model in legacy graph mode with tuning and 8 GPUs.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test trivial Keras model (input pipeline) in legacy graph mode with",
   "   manual config tuning and 8 GPUs.",
   "\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test Keras model in legacy graph mode, tuning, 8 GPUs, and FP16.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model in legacy graph mode with manual config tuning, 8 GPUs",
   "   and fp16.",
   "\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test Keras model in legacy graph with 1 GPU, fp16, XLA, and tuning.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model in legacy graph mode with 1 GPU, fp16, XLA, and manual",
   "   config tuning.",
   "\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "{'pin_to_host_optimization': False}"
  ],
  "consequent": [
   "{\"pin_to_host_optimization\": False}"
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test trivial Keras model with tuning and 8 GPUs.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test trivial Keras model (input pipeline) with manual config tuning and",
   "   8 GPUs.",
   "\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "import tensorflow as tf  # pylint: disable=g-bad-import-order"
  ],
  "consequent": [
   "import tensorflow as tf # pylint: disable=g-bad-import-order"
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "# TODO(b/76028325): Remove when generic layout optimizer is ready.",
   "flags.DEFINE_boolean(",
   "    name='enable_grappler_layout_optimizer',",
   "    default=True,",
   "    help='Enable Grappler layout optimizer. Currently Grappler can '",
   "         'de-optimize fp16 graphs byt forcing NCHW layout for all '",
   "         'convolutions and batch normalizations, and this flag allows to '",
   "         'disable it.'",
   ")"
  ],
  "consequent": []
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test legacy graph mode with tf.data's experimental_slack.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model in legacy graph mode with tf.data's experimental_slack",
   "   functionality, XLA, 8 GPUs and fp16.",
   "\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test Keras model tf.data's experimental_slack functionality.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model with XLA, 1 GPU, fp16, and tf.data's experimental_slack",
   "   functionality.\"\"\""
  ]
 },
 {
  "sha": "097c8051ac47ce23700d887706cff82c8adfa314",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 02:09:34",
  "condition": [
   "\"\"\"Test model in legacy graph with tf.data's experimental_slack.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model in legacy graph mode with 1 GPU, fp16, XLA, and",
   "   tf.data's experimental_slack functionality.",
   "\"\"\""
  ]
 },
 {
  "sha": "7b329985a22c6ca219f093ed6b83a2913b285296",
  "author": "Toby Boyd",
  "created_at": "2019-06-15 01:50:50",
  "condition": [
   "\"\"\"Test keras based model with forced eager and no dist_strat.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test keras based model with forced eager.\"\"\""
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "Directory where image features are located, all in .delf format."
  ],
  "consequent": [
   "Directory where query image features are located, all in .delf format."
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "feature.plot_matches("
  ],
  "consequent": [
   "plot_matches("
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "extractor_fn = extractor.MakeExtractor(sess, config)"
  ],
  "consequent": [
   "extractor_fn = extract_features.MakeExtractor(sess, config)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   " ]",
   " # Extract boxes/features and save them to files.",
   " boxes_and_features_extraction.ExtractBoxesAndFeaturesToFiles(",
   "     image_names=index_list,",
   "     image_paths=image_paths,",
   "     delf_config_path=cmd_args.delf_config_path,",
   "     detector_model_dir=cmd_args.detector_model_dir,",
   "     detector_thresh=cmd_args.detector_thresh,",
   "     output_features_dir=cmd_args.output_features_dir,",
   "     output_boxes_dir=cmd_args.output_boxes_dir,"
  ],
  "consequent": [
   "output_box_filename = os.path.join(cmd_args.output_boxes_dir,"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "from delf.python.examples import detector",
   "from delf.python.examples import extractor"
  ],
  "consequent": [
   "from delf.python.examples import extract_boxes",
   "from delf.python.examples import extract_features"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "extractor_fn = extractor.MakeExtractor(sess, config)"
  ],
  "consequent": [
   "extractor_fn = MakeExtractor(sess, config)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "from delf.python.detect_to_retrieve import aggregation_extraction"
  ],
  "consequent": [
   "from delf import aggregation_config_pb2",
   "from delf import datum_io",
   "from delf import feature_aggregation_extractor",
   "from delf import feature_io"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "if not tf.gfile.Exists(cmd_args.output_features_dir):"
  ],
  "consequent": [
   "if not os.path.exists(cmd_args.output_features_dir):"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "from scipy import spatial",
   "from skimage import feature",
   "from skimage import measure",
   "from skimage import transform"
  ],
  "consequent": [
   "from scipy.spatial import cKDTree",
   "from skimage.feature import plot_matches",
   "from skimage.measure import ransac",
   "from skimage.transform import AffineTransform"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "features_dir=cmd_args.features_dir,",
   "aggregation_config_path=cmd_args.aggregation_config_path,"
  ],
  "consequent": [
   "     # Compose output file name, skip extraction for this image if it already",
   "     # exists.",
   "     output_aggregation_filename = os.path.join(",
   "         cmd_args.output_aggregation_dir, image_name + output_extension)",
   "     if tf.io.gfile.exists(output_aggregation_filename):",
   "       print('Skipping %s' % image_name)",
   "       continue",
   "     # Load DELF features.",
   "     if config.use_regional_aggregation:"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "if not tf.gfile.Exists(cmd_args.output_dir):"
  ],
  "consequent": [
   "if not os.path.exists(cmd_args.output_dir):"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "mapping_path=cmd_args.index_mapping_path,"
  ],
  "consequent": [
   "if not cmd_args.index_mapping_path:"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "print('done! Found %d images' % num_images)"
  ],
  "consequent": [
   "tf.logging.info('done! Found %d images', num_images)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "from delf import extractor"
  ],
  "consequent": [
   "from delf import extract_features"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "output_aggregation_dir=cmd_args.output_aggregation_dir)"
  ],
  "consequent": [
   "         raise ValueError(",
   "             'Requested regional aggregation, but index_mapping_path was not '",
   "             'provided')",
   "       descriptors_list = []",
   "       num_features_per_box = []",
   "       for box_feature_file in images_to_box_feature_files[image_name]:",
   "         delf_filename = os.path.join(cmd_args.features_dir,",
   "                                      box_feature_file + _DELF_EXTENSION)",
   "         _, _, box_descriptors, _, _ = feature_io.ReadFromFile(delf_filename)",
   "         # If `box_descriptors` is empty, reshape it such that it can be",
   "         # concatenated with other descriptors.",
   "         if not box_descriptors.shape[0]:",
   "           box_descriptors = np.reshape(box_descriptors,",
   "                                        [0, config.feature_dimensionality])",
   "         descriptors_list.append(box_descriptors)",
   "         num_features_per_box.append(box_descriptors.shape[0])",
   "       descriptors = np.concatenate(descriptors_list)",
   "     else:",
   "       input_delf_filename = os.path.join(cmd_args.features_dir,",
   "                                          image_name + _DELF_EXTENSION)",
   "       _, _, descriptors, _, _ = feature_io.ReadFromFile(input_delf_filename)",
   "       num_features_per_box = None",
   "     # Extract and save aggregation. If using VLAD, only",
   "     # `aggregated_descriptors` needs to be saved.",
   "     (aggregated_descriptors,",
   "      feature_visual_words) = extractor.Extract(descriptors,",
   "                                                num_features_per_box)",
   "     if config.aggregation_type == _VLAD:",
   "       datum_io.WriteToFile(aggregated_descriptors,",
   "                            output_aggregation_filename)",
   "     else:",
   "       datum_io.WritePairToFile(aggregated_descriptors,",
   "                                feature_visual_words.astype('uint32'),",
   "                                output_aggregation_filename)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "tf.gfile.MakeDirs(cmd_args.output_dir)"
  ],
  "consequent": [
   "os.makedirs(cmd_args.output_dir)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "image_names=image_list,"
  ],
  "consequent": [
   "image_name = image_list[i]"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "tf.gfile.MakeDirs(cmd_args.output_cluster_dir)"
  ],
  "consequent": [
   "os.makedirs(cmd_args.output_cluster_dir)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "print('Reading list of index images from dataset file...')"
  ],
  "consequent": [
   "tf.logging.info('Reading list of index images from dataset file...')"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "if tf.gfile.Exists(cmd_args.output_cluster_dir):"
  ],
  "consequent": [
   "if os.path.exists(cmd_args.output_cluster_dir):"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "for index_image_name in index_list"
  ],
  "consequent": [
   "index_image_name = index_list[i]",
   "input_image_filename = os.path.join(cmd_args.images_dir,",
   "                                    index_image_name + _IMAGE_EXTENSION)",
   "output_feature_filename_whole_image = os.path.join(",
   "    cmd_args.output_features_dir, index_image_name + _DELF_EXTENSION)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "_, inliers = measure.ransac((locations_1_to_use, locations_2_to_use),",
   "                            transform.AffineTransform,",
   "                            min_samples=3,",
   "                            residual_threshold=20,",
   "                            max_trials=1000)"
  ],
  "consequent": [
   "_, inliers = ransac(",
   "    (locations_1_to_use, locations_2_to_use),",
   "    AffineTransform,",
   "    min_samples=3,",
   "    residual_threshold=20,",
   "    max_trials=1000)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "tf.gfile.MakeDirs(cmd_args.output_features_dir)"
  ],
  "consequent": [
   "os.makedirs(cmd_args.output_features_dir)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "detector_fn = detector.MakeDetector(sess, cmd_args.detector_path)"
  ],
  "consequent": [
   "detector_fn = MakeDetector(sess, cmd_args.detector_path)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "tf.gfile.MakeDirs(cmd_args.output_viz_dir)"
  ],
  "consequent": [
   "os.makedirs(cmd_args.output_viz_dir)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "aggregation_extraction.ExtractAggregatedRepresentationsToFiles("
  ],
  "consequent": [
   " # Parse AggregationConfig proto, and select output extension.",
   " config = aggregation_config_pb2.AggregationConfig()",
   " with tf.gfile.GFile(cmd_args.aggregation_config_path, 'r') as f:",
   "   text_format.Merge(f.read(), config)",
   " output_extension = '.'",
   " if config.use_regional_aggregation:",
   "   output_extension += 'r'",
   " if config.aggregation_type == _VLAD:",
   "   output_extension += _VLAD_EXTENSION_SUFFIX",
   " elif config.aggregation_type == _ASMK:",
   "   output_extension += _ASMK_EXTENSION_SUFFIX",
   " elif config.aggregation_type == _ASMK_STAR:",
   "   output_extension += _ASMK_STAR_EXTENSION_SUFFIX",
   " else:",
   "   raise ValueError('Invalid aggregation type: %d' % config.aggregation_type)",
   " # Read index mapping path, if provided.",
   " if cmd_args.index_mapping_path:",
   "   images_to_box_feature_files = _ReadMappingBasenameToBoxNames(",
   "       cmd_args.index_mapping_path, image_list)",
   " # Create output directory if necessary.",
   " if not os.path.exists(cmd_args.output_aggregation_dir):",
   "   os.makedirs(cmd_args.output_aggregation_dir)",
   " with tf.Session() as sess:",
   "   extractor = feature_aggregation_extractor.ExtractAggregatedRepresentation(",
   "       sess, config)",
   "   start = time.clock()",
   "   for i in range(num_images):",
   "     if i == 0:",
   "       print('Starting to extract aggregation from images...')",
   "     elif i % _STATUS_CHECK_ITERATIONS == 0:",
   "       elapsed = (time.clock() - start)",
   "       print('Processing image %d out of %d, last %d '",
   "             'images took %f seconds' %",
   "             (i, num_images, _STATUS_CHECK_ITERATIONS, elapsed))",
   "       start = time.clock()"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "from delf.python.detect_to_retrieve import boxes_and_features_extraction"
  ],
  "consequent": [
   "from delf import delf_config_pb2",
   "from delf import box_io",
   "from delf import feature_io"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "output_mapping=cmd_args.output_index_mapping)"
  ],
  "consequent": [
   "                                          index_image_name + _BOX_EXTENSION)",
   "       pil_im = _PilLoader(input_image_filename)",
   "       width, height = pil_im.size",
   "       # Extract and save boxes.",
   "       if tf.gfile.Exists(output_box_filename):",
   "         tf.logging.info('Skipping box computation for %s', index_image_name)",
   "         (boxes_out, scores_out,",
   "          class_indices_out) = box_io.ReadFromFile(output_box_filename)",
   "       else:",
   "         (boxes_out, scores_out,",
   "          class_indices_out) = detector_fn(np.expand_dims(pil_im, 0))",
   "         # Using only one image per batch.",
   "         boxes_out = boxes_out[0]",
   "         scores_out = scores_out[0]",
   "         class_indices_out = class_indices_out[0]",
   "         box_io.WriteToFile(output_box_filename, boxes_out, scores_out,",
   "                            class_indices_out)",
   "       # Select boxes with scores greater than threshold. Those will be the",
   "       # ones with extracted DELF features (besides the whole image, whose DELF",
   "       # features are extracted in all cases).",
   "       num_delf_files = 1",
   "       selected_boxes = []",
   "       for box_ind, box in enumerate(boxes_out):",
   "         if scores_out[box_ind] >= cmd_args.detector_thresh:",
   "           selected_boxes.append(box)",
   "       num_delf_files += len(selected_boxes)",
   "       # Extract and save DELF features.",
   "       for delf_file_ind in range(num_delf_files):",
   "         if delf_file_ind == 0:",
   "           index_box_name = index_image_name",
   "           output_feature_filename = output_feature_filename_whole_image",
   "         else:",
   "           index_box_name = index_image_name + '_' + str(delf_file_ind - 1)",
   "           output_feature_filename = os.path.join(",
   "               cmd_args.output_features_dir, index_box_name + _DELF_EXTENSION)",
   "         index_names_ids_and_boxes.append(",
   "             [index_box_name, i, delf_file_ind - 1])",
   "         if tf.gfile.Exists(output_feature_filename):",
   "           tf.logging.info('Skipping DELF computation for %s', index_box_name)",
   "           continue",
   "         if delf_file_ind >= 1:",
   "           bbox_for_cropping = selected_boxes[delf_file_ind - 1]",
   "           bbox_for_cropping_pil_convention = [",
   "               int(math.floor(bbox_for_cropping[1] * width)),",
   "               int(math.floor(bbox_for_cropping[0] * height)),",
   "               int(math.ceil(bbox_for_cropping[3] * width)),",
   "               int(math.ceil(bbox_for_cropping[2] * height))",
   "           ]",
   "           pil_cropped_im = pil_im.crop(bbox_for_cropping_pil_convention)",
   "           im = np.array(pil_cropped_im)",
   "         else:",
   "           im = np.array(pil_im)",
   "         (locations_out, descriptors_out, feature_scales_out,",
   "          attention_out) = delf_extractor_fn(im)",
   "         feature_io.WriteToFile(output_feature_filename, locations_out,",
   "                                feature_scales_out, descriptors_out,",
   "                                attention_out)",
   " # Save mapping from output DELF name to index image id and box id.",
   " _WriteMappingBasenameToIds(index_names_ids_and_boxes,",
   "                            cmd_args.output_index_mapping)"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "if cmd_args.output_viz_dir and not tf.gfile.Exists(cmd_args.output_viz_dir):"
  ],
  "consequent": [
   "if cmd_args.output_viz_dir and not os.path.exists(cmd_args.output_viz_dir):"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "# Compose list of image paths.",
   "image_paths = [",
   "    os.path.join(cmd_args.images_dir, index_image_name + _IMAGE_EXTENSION)"
  ],
  "consequent": [
   " # Parse DelfConfig proto.",
   " config = delf_config_pb2.DelfConfig()",
   " with tf.gfile.GFile(cmd_args.delf_config_path, 'r') as f:",
   "   text_format.Merge(f.read(), config)",
   " # Create output directories if necessary.",
   " if not os.path.exists(cmd_args.output_features_dir):",
   "   os.makedirs(cmd_args.output_features_dir)",
   " if not os.path.exists(cmd_args.output_boxes_dir):",
   "   os.makedirs(cmd_args.output_boxes_dir)",
   " index_names_ids_and_boxes = []",
   " with tf.Graph().as_default():",
   "   with tf.Session() as sess:",
   "     # Initialize variables, construct detector and DELF extractor.",
   "     init_op = tf.global_variables_initializer()",
   "     sess.run(init_op)",
   "     detector_fn = extract_boxes.MakeDetector(",
   "         sess, cmd_args.detector_model_dir, import_scope='detector')",
   "     delf_extractor_fn = extract_features.MakeExtractor(",
   "         sess, config, import_scope='extractor_delf')",
   "     start = time.clock()",
   "     for i in range(num_images):",
   "       if i == 0:",
   "         print('Starting to extract features/boxes from index images...')",
   "       elif i % _STATUS_CHECK_ITERATIONS == 0:",
   "         elapsed = (time.clock() - start)",
   "         print('Processing index image %d out of %d, last %d '",
   "               'images took %f seconds' %",
   "               (i, num_images, _STATUS_CHECK_ITERATIONS, elapsed))",
   "         start = time.clock()"
  ]
 },
 {
  "sha": "7cd29f8cd9dccd9f20d369ae1f9e401ea742de92",
  "author": "Andr\u00e9 Araujo",
  "created_at": "2019-06-14 09:44:31",
  "condition": [
   "d1_tree = spatial.cKDTree(descriptors_1)"
  ],
  "consequent": [
   "d1_tree = cKDTree(descriptors_1)"
  ]
 },
 {
  "sha": "d8a090642c2a40bd0b019d7c21b407d376fc7e2e",
  "author": "Toby Boyd",
  "created_at": "2019-06-14 07:59:40",
  "condition": [
   "import tensorflow as tf  # pylint: disable=g-bad-import-order"
  ],
  "consequent": [
   "import tensorflow as tf # pylint: disable=g-bad-import-order"
  ]
 },
 {
  "sha": "f6f04066f893f15899ce077c2281541ff2fbb5eb",
  "author": "guptapriya",
  "created_at": "2019-06-12 06:28:07",
  "condition": [
   "extra_flags=flags)"
  ],
  "consequent": [
   "extra_flags=self._BASE_END_TO_END_FLAGS + ['-num_gpus', '0'])"
  ]
 },
 {
  "sha": "f6f04066f893f15899ce077c2281541ff2fbb5eb",
  "author": "guptapriya",
  "created_at": "2019-06-12 06:28:07",
  "condition": [
   "if (params[\"keras_use_ctl\"] and (",
   "    not ncf_common.is_tf_v2() or strategy is None)):"
  ],
  "consequent": [
   "if params[\"keras_use_ctl\"] and int(tf.__version__.split(\".\")[0]) == 1:"
  ]
 },
 {
  "sha": "f6f04066f893f15899ce077c2281541ff2fbb5eb",
  "author": "guptapriya",
  "created_at": "2019-06-12 06:28:07",
  "condition": [
   "\"Custom training loop only works with tensorflow 2.0 and dist strat.\")"
  ],
  "consequent": [
   "\"Custom training loop only works with tensorflow 2.0 and above.\")"
  ]
 },
 {
  "sha": "f6f04066f893f15899ce077c2281541ff2fbb5eb",
  "author": "guptapriya",
  "created_at": "2019-06-12 06:28:07",
  "condition": [
   "if params[\"distribute_strategy\"] or not ncf_common.is_tf_v2():"
  ],
  "consequent": [
   "if params[\"distribute_strategy\"]:"
  ]
 },
 {
  "sha": "f6f04066f893f15899ce077c2281541ff2fbb5eb",
  "author": "guptapriya",
  "created_at": "2019-06-12 06:28:07",
  "condition": [
   "def step_fn(features):"
  ],
  "consequent": [
   "def step_fn(inputs):"
  ]
 },
 {
  "sha": "8f44de85c73f49e9eaf9b8ddbd725acb8c6c851f",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:49:23",
  "condition": [
   "def test_end_to_end_keras_no_dist_strat(self):"
  ],
  "consequent": [
   "def test_end_to_end_keras(self):"
  ]
 },
 {
  "sha": "8f44de85c73f49e9eaf9b8ddbd725acb8c6c851f",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:49:23",
  "condition": [
   "def test_end_to_end_keras_1_gpu_dist_strat(self):"
  ],
  "consequent": [
   "def test_end_to_end_keras_1_gpu(self):"
  ]
 },
 {
  "sha": "8f44de85c73f49e9eaf9b8ddbd725acb8c6c851f",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:49:23",
  "condition": [
   "       extra_flags=self._BASE_END_TO_END_FLAGS + ['-num_gpus', '0'])",
   " @mock.patch.object(rconst, \"SYNTHETIC_BATCHES_PER_EPOCH\", 100)",
   " def test_end_to_end_keras_dist_strat_ctl(self):",
   "   flags = (self._BASE_END_TO_END_FLAGS +"
  ],
  "consequent": [
   "extra_flags=self._BASE_END_TO_END_FLAGS +",
   "['-ml_perf', 'True',",
   " '-distribution_strategy', 'off'])"
  ]
 },
 {
  "sha": "8f44de85c73f49e9eaf9b8ddbd725acb8c6c851f",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:49:23",
  "condition": [
   "def test_end_to_end_keras_dist_strat(self):"
  ],
  "consequent": [
   "def test_end_to_end_keras_mlperf(self):"
  ]
 },
 {
  "sha": "bed2745d3c5d9ad74650a518a945eb6c95004c56",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:35:19",
  "condition": [
   "features[rconst.VALID_POINT_MASK] = fake_valid_pt_mask"
  ],
  "consequent": [
   "features[rconst.VALID_POINT_MASK] = fake_valit_pt_mask"
  ]
 },
 {
  "sha": "bed2745d3c5d9ad74650a518a945eb6c95004c56",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:35:19",
  "condition": [],
  "consequent": [
   "",
   "\"\"\"Run NCF training and eval with Keras.\"\"\""
  ]
 },
 {
  "sha": "bed2745d3c5d9ad74650a518a945eb6c95004c56",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:35:19",
  "condition": [],
  "consequent": [
   "strategy = distribution_utils.get_distribution_strategy(",
   "    distribution_strategy=FLAGS.distribution_strategy,",
   "    num_gpus=FLAGS.num_gpus)"
  ]
 },
 {
  "sha": "bed2745d3c5d9ad74650a518a945eb6c95004c56",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:35:19",
  "condition": [
   "This is needed becasue:"
  ],
  "consequent": [
   "This is needed because:",
   "- Distributed training with keras fit does not support extra inputs. The",
   "  current implementation for fit does not use the DUPLICATE_MASK in the",
   "  input, which makes it extra, so it needs to be removed when using keras",
   "  fit."
  ]
 },
 {
  "sha": "bed2745d3c5d9ad74650a518a945eb6c95004c56",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:35:19",
  "condition": [
   "This is needed because"
  ],
  "consequent": [
   "This is needed because:",
   "- Distributed training with keras fit does not support extra inputs. The",
   "  current implementation for fit does not use the VALID_POINT_MASK in the",
   "  input, which makes it extra, so it needs to be removed when using keras",
   "  fit."
  ]
 },
 {
  "sha": "bed2745d3c5d9ad74650a518a945eb6c95004c56",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:35:19",
  "condition": [
   "fake_valid_pt_mask = tf.cast("
  ],
  "consequent": [
   "fake_valit_pt_mask = tf.cast("
  ]
 },
 {
  "sha": "bed2745d3c5d9ad74650a518a945eb6c95004c56",
  "author": "guptapriya",
  "created_at": "2019-06-12 05:35:19",
  "condition": [
   "   if params[\"distribute_strategy\"]:",
   "     return features",
   "   else:",
   "     # b/134708104",
   "     return (features,)"
  ],
  "consequent": [
   "#return (features,)",
   "return features, labels"
  ]
 },
 {
  "sha": "9214db1d116f77c855a4274e10543b987048dca3",
  "author": "guptapriya",
  "created_at": "2019-06-12 04:45:19",
  "condition": [
   "\"val_HR_METRIC\", desired_value=FLAGS.hr_threshold)"
  ],
  "consequent": [
   "\"val_metric_fn\", desired_value=FLAGS.hr_threshold)"
  ]
 },
 {
  "sha": "8f6e2547106fcbc2c53a20bdb4454d88e55bed7d",
  "author": "guptapriya",
  "created_at": "2019-06-12 04:41:50",
  "condition": [
   "loss_object = tf.keras.losses.SparseCategoricalCrossentropy("
  ],
  "consequent": [
   "loss_object = tf.losses.SparseCategoricalCrossentropy("
  ]
 },
 {
  "sha": "6da769b18d25238219fbe299bd0fadbca55b59d5",
  "author": "guptapriya",
  "created_at": "2019-06-12 03:27:34",
  "condition": [
   "sample_weight=valid_pt_mask_input) * 1.0 / batch_size)"
  ],
  "consequent": [
   "sample_weight=valid_pt_mask_input) * 1.0 / loss_scale_factor)"
  ]
 },
 {
  "sha": "71c6a697af624304d9b48e7ad4c617911be51041",
  "author": "guptapriya",
  "created_at": "2019-06-07 13:09:27",
  "condition": [
   "#tf.distribute.get_strategy().num_replicas_in_sync)"
  ],
  "consequent": [
   "tf.distribute.get_strategy().num_replicas_in_sync)"
  ]
 },
 {
  "sha": "71c6a697af624304d9b48e7ad4c617911be51041",
  "author": "guptapriya",
  "created_at": "2019-06-07 13:09:27",
  "condition": [
   "loss_scale_factor = (batch_size) #*"
  ],
  "consequent": [
   "loss_scale_factor = (batch_size *"
  ]
 },
 {
  "sha": "71c6a697af624304d9b48e7ad4c617911be51041",
  "author": "guptapriya",
  "created_at": "2019-06-07 13:09:27",
  "condition": [
   "strategy = distribution_utils.get_distribution_strategy(",
   "    distribution_strategy=FLAGS.distribution_strategy,",
   "    num_gpus=FLAGS.num_gpus)"
  ],
  "consequent": [
   "strategy = ncf_common.get_distribution_strategy(params)"
  ]
 },
 {
  "sha": "39704281a37ac193f08a2abde541e04a6bc4e8d9",
  "author": "Erekle",
  "created_at": "2019-06-12 23:46:51",
  "condition": [
   "seg_data = tf.gfile.FastGFile(seg_filename, 'rb').read()"
  ],
  "consequent": [
   "seg_data = tf.gfile.FastGFile(seg_filename, 'r').read()"
  ]
 },
 {
  "sha": "39704281a37ac193f08a2abde541e04a6bc4e8d9",
  "author": "Erekle",
  "created_at": "2019-06-12 23:46:51",
  "condition": [
   "image_data = tf.gfile.FastGFile(image_filename, 'rb').read()"
  ],
  "consequent": [
   "image_data = tf.gfile.FastGFile(image_filename, 'r').read()"
  ]
 },
 {
  "sha": "f7a44074a1acb6c5889015ecb7bb5a14379b4bef",
  "author": "rxsang",
  "created_at": "2019-06-11 03:48:41",
  "condition": [
   "dtype=dtype)"
  ],
  "consequent": [
   "dtype=dtype,",
   "batch_size=input_layer_batch_size)"
  ]
 },
 {
  "sha": "415e8a450f289bcbc8c665d7a68cf36e12101155",
  "author": "davidmochen",
  "created_at": "2019-06-07 09:33:33",
  "condition": [
   "def train_squad(strategy, input_meta_data, custom_callbacks=None):"
  ],
  "consequent": [
   "def train_squad(strategy, input_meta_data):"
  ]
 },
 {
  "sha": "415e8a450f289bcbc8c665d7a68cf36e12101155",
  "author": "davidmochen",
  "created_at": "2019-06-07 09:33:33",
  "condition": [
   "use_remote_tpu=use_remote_tpu,"
  ],
  "consequent": [
   "use_remote_tpu=use_remote_tpu)"
  ]
 },
 {
  "sha": "415e8a450f289bcbc8c665d7a68cf36e12101155",
  "author": "davidmochen",
  "created_at": "2019-06-07 09:33:33",
  "condition": [
   "class BertClassifyBenchmarkReal(BertClassifyBenchmarkBase):"
  ],
  "consequent": [
   "class BertClassifyBenchmarkReal(BertBenchmarkBase):"
  ]
 },
 {
  "sha": "415e8a450f289bcbc8c665d7a68cf36e12101155",
  "author": "davidmochen",
  "created_at": "2019-06-07 09:33:33",
  "condition": [
   "class BertClassifyBenchmarkBase(benchmark_utils.BertBenchmarkBase):"
  ],
  "consequent": [
   "class BenchmarkTimerCallback(tf.keras.callbacks.Callback):",
   "  \"\"\"Callback that records time it takes to run each batch.\"\"\"",
   "",
   "  def __init__(self, num_batches_to_skip=10):",
   "    super(BenchmarkTimerCallback, self).__init__()",
   "    self.num_batches_to_skip = num_batches_to_skip",
   "    self.timer_records = []",
   "    self.start_time = None",
   "",
   "  def on_batch_start(self, batch, logs=None):",
   "    if batch < self.num_batches_to_skip:",
   "      return",
   "    self.start_time = time.time()",
   "",
   "  def on_batch_end(self, batch, logs=None):",
   "    if batch < self.num_batches_to_skip:",
   "      return",
   "",
   "    assert self.start_time",
   "    self.timer_records.append(time.time() - self.start_time)",
   "",
   "  def get_examples_per_sec(self, batch_size):",
   "    return batch_size / np.mean(self.timer_records)",
   "",
   "",
   "class BertBenchmarkBase(tf.test.Benchmark):"
  ]
 },
 {
  "sha": "415e8a450f289bcbc8c665d7a68cf36e12101155",
  "author": "davidmochen",
  "created_at": "2019-06-07 09:33:33",
  "condition": [
   "super(BertClassifyBenchmarkBase, self).__init__(output_dir)"
  ],
  "consequent": [
   "   if not output_dir:",
   "     output_dir = '/tmp'",
   "   self.output_dir = output_dir",
   "   self.timer_callback = None",
   " def _get_model_dir(self, folder_name):",
   "   \"\"\"Returns directory to store info, e.g. saved model and event log.\"\"\"",
   "   return os.path.join(self.output_dir, folder_name)",
   " def _setup(self):",
   "   \"\"\"Sets up and resets flags before each test.\"\"\"",
   "   tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.DEBUG)",
   "   self.timer_callback = BenchmarkTimerCallback()",
   "   if BertBenchmarkBase.local_flags is None:",
   "     # Loads flags to get defaults to then override. List cannot be empty.",
   "     flags.FLAGS(['foo'])",
   "     saved_flag_values = flagsaver.save_flag_values()",
   "     BertBenchmarkBase.local_flags = saved_flag_values",
   "   else:",
   "     flagsaver.restore_flag_values(BertBenchmarkBase.local_flags)",
   " def _report_benchmark(self, stats, wall_time_sec, min_accuracy, max_accuracy):",
   "   \"\"\"Report benchmark results by writing to local protobuf file.",
   "   Args:",
   "     stats: dict returned from BERT models with known entries.",
   "     wall_time_sec: the during of the benchmark execution in seconds",
   "     min_accuracy: Minimum classification accuracy constraint to verify",
   "       correctness of the model.",
   "     max_accuracy: Maximum classification accuracy constraint to verify",
   "       correctness of the model.",
   "   \"\"\"",
   "   metrics = [{",
   "       'name': 'training_loss',",
   "       'value': stats['train_loss'],",
   "   }, {",
   "       'name':",
   "           'exp_per_second',",
   "       'value':",
   "           self.timer_callback.get_examples_per_sec(FLAGS.train_batch_size)",
   "   }]",
   "   if 'eval_metrics' in stats:",
   "     metrics.append({",
   "         'name': 'eval_accuracy',",
   "         'value': stats['eval_metrics'],",
   "         'min_value': min_accuracy,",
   "         'max_value': max_accuracy,",
   "     })",
   "   self.report_benchmark(",
   "       iters=stats['total_training_steps'],",
   "       wall_time=wall_time_sec,",
   "       metrics=metrics)"
  ]
 },
 {
  "sha": "415e8a450f289bcbc8c665d7a68cf36e12101155",
  "author": "davidmochen",
  "created_at": "2019-06-07 09:33:33",
  "condition": [
   "class BertClassifyAccuracy(BertClassifyBenchmarkBase):"
  ],
  "consequent": [
   "class BertClassifyAccuracy(BertBenchmarkBase):"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "'loss_scale': flags_core.get_loss_scale(flags_obj,"
  ],
  "consequent": [
   "'loss_scale': flags_core.get_loss_scale(flags_obj),"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "return DTYPE_MAP[flags_obj.dtype]"
  ],
  "consequent": [
   "return DTYPE_MAP[flags_obj.dtype][0]"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "def get_loss_scale(flags_obj, default_for_fp16):"
  ],
  "consequent": [
   "def get_loss_scale(flags_obj):"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "self.assertEqual(flags_core.get_loss_scale(flags.FLAGS,"
  ],
  "consequent": [
   "self.assertEqual(flags_core.get_loss_scale(flags.FLAGS), 5)"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "flags_core.parse_flags(",
   "    [__file__, \"--dtype\", \"fp16\", \"--loss_scale\", \"5\"])",
   "self.assertEqual(flags_core.get_loss_scale(flags.FLAGS,"
  ],
  "consequent": [
   "self.assertEqual(flags_core.get_tf_dtype(flags.FLAGS), tf_dtype)",
   "self.assertEqual(flags_core.get_loss_scale(flags.FLAGS), loss_scale)"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "\"fp16\": tf.float16,"
  ],
  "consequent": [
   "\"fp16\": (tf.float16, 128),"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "flags_core.parse_flags([__file__, \"--dtype\", \"fp32\"])",
   "self.assertEqual(flags_core.get_tf_dtype(flags.FLAGS), tf.float32)"
  ],
  "consequent": [
   "flags_core.parse_flags(",
   "    [__file__, \"--dtype\", dtype_str, \"--loss_scale\", \"dynamic\"])"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "flags_core.parse_flags([__file__, \"--dtype\", \"fp16\"])"
  ],
  "consequent": [
   "for dtype_str, tf_dtype, loss_scale in [[\"fp16\", tf.float16, 128],",
   "                                        [\"fp32\", tf.float32, 1]]:",
   "  flags_core.parse_flags([__file__, \"--dtype\", dtype_str])"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "optimizer, loss_scale=flags_core.get_loss_scale(flags_obj,"
  ],
  "consequent": [
   "optimizer, loss_scale=flags_core.get_loss_scale(flags_obj))"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "\"fp32\": tf.float32,"
  ],
  "consequent": [
   "\"fp32\": (tf.float32, 1),"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "elif flags_obj.dtype == \"fp32\":",
   "  return 1  # No loss scaling is needed for fp32",
   "else:",
   "  assert flags_obj.dtype == \"fp16\"",
   "  return default_for_fp16"
  ],
  "consequent": [
   "return DTYPE_MAP[flags_obj.dtype][1]"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "# Map string to TensorFlow dtype"
  ],
  "consequent": [
   "# Map string to (TensorFlow dtype, default loss scale)"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "[__file__, \"--dtype\", \"fp16\", \"--loss_scale\", \"dynamic\"])"
  ],
  "consequent": [
   "[__file__, \"--dtype\", dtype_str, \"--loss_scale\", \"5\"])"
  ]
 },
 {
  "sha": "42a8af1d9574d89ba8da812acb550a27318de019",
  "author": "Reed",
  "created_at": "2019-06-07 08:45:21",
  "condition": [
   "self.assertEqual(flags_core.get_loss_scale(flags.FLAGS,"
  ],
  "consequent": [
   "self.assertEqual(flags_core.get_loss_scale(flags.FLAGS), \"dynamic\")"
  ]
 },
 {
  "sha": "0a83bef97c2ea61d61f517f4516827d4f8efa877",
  "author": "Reed",
  "created_at": "2019-06-07 08:43:38",
  "condition": [
   "flags_str = flags_core.get_nondefault_flags_as_str()",
   "self.report_benchmark(iters=-1, wall_time=wall_time_sec, metrics=metrics,"
  ],
  "consequent": [
   "self.report_benchmark(iters=-1, wall_time=wall_time_sec, metrics=metrics)"
  ]
 },
 {
  "sha": "8b18491b26e4b8271db757a3245008882ea112b3",
  "author": "guptapriya",
  "created_at": "2019-06-06 14:30:53",
  "condition": [
   "tf.io.gfile.GFile(ref_filename).read()).strip().splitlines()"
  ],
  "consequent": [
   "tf.gfile.Open(ref_filename, \"r\").read()).split(\"\\n\")"
  ]
 },
 {
  "sha": "8b18491b26e4b8271db757a3245008882ea112b3",
  "author": "guptapriya",
  "created_at": "2019-06-06 14:30:53",
  "condition": [
   "tf.io.gfile.GFile(hyp_filename).read()).strip().splitlines()"
  ],
  "consequent": [
   "tf.gfile.Open(hyp_filename, \"r\").read()).split(\"\\n\")"
  ]
 },
 {
  "sha": "152baba567a8f2e14b04a3e32ecbc509662e55e7",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-06 11:50:43",
  "condition": [
   "FLAGS.batch_size = 256 * 8"
  ],
  "consequent": [
   "FLAGS.batch_size = 256 * 8  # 8 GPUs"
  ]
 },
 {
  "sha": "152baba567a8f2e14b04a3e32ecbc509662e55e7",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-06 11:50:43",
  "condition": [
   "FLAGS.datasets_num_private_threads = 48"
  ],
  "consequent": [
   "   FLAGS.data_delay_prefetch = True",
   "   self._run_and_report_benchmark()",
   " def benchmark_8_gpu_slack(self):",
   "   \"\"\"Test trivial Keras model (input pipeline) with tf.data's",
   "      experimental_slack and 8 GPUs.",
   "   \"\"\"",
   "   self._setup()",
   "   FLAGS.num_gpus = 8",
   "   FLAGS.enable_eager = True",
   "   FLAGS.enable_xla = True",
   "   FLAGS.model_dir = self._get_model_dir('benchmark_8_gpu_slack')",
   "   FLAGS.batch_size = 256 * 8",
   "   FLAGS.tf_data_experimental_slack = True"
  ]
 },
 {
  "sha": "152baba567a8f2e14b04a3e32ecbc509662e55e7",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-06 11:50:43",
  "condition": [
   "FLAGS.tf_gpu_thread_mode = 'gpu_private'"
  ],
  "consequent": [
   "# FLAGS.tf_gpu_thread_mode = 'gpu_private'"
  ]
 },
 {
  "sha": "152baba567a8f2e14b04a3e32ecbc509662e55e7",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-06 11:50:43",
  "condition": [
   "FLAGS.datasets_num_private_threads = 48"
  ],
  "consequent": [
   "FLAGS.data_delay_prefetch = True"
  ]
 },
 {
  "sha": "152baba567a8f2e14b04a3e32ecbc509662e55e7",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-06 11:50:43",
  "condition": [
   "FLAGS.batch_size = 256 * 8"
  ],
  "consequent": [
   "FLAGS.batch_size = 256"
  ]
 },
 {
  "sha": "e4bf28fc63b958406c5700f413f037b2344b7f8a",
  "author": "guptapriya",
  "created_at": "2019-06-06 08:07:35",
  "condition": [
   "print(\"For training, using distribution strategy: \","
  ],
  "consequent": [
   "print(\"For training, using distribution strategy: \", self.distribution_strategy)"
  ]
 },
 {
  "sha": "2a56bb7e13bf8794e0f5605a3eae0cb66d7cd009",
  "author": "guptapriya",
  "created_at": "2019-06-05 16:11:16",
  "condition": [
   "self.vocab_size = misc.get_model_params(FLAGS.param_set, 0)[\"vocab_size\"]"
  ],
  "consequent": [
   "self.vocab_size = misc.get_model_params(param_set, 0)[\"vocab_size\"]"
  ]
 },
 {
  "sha": "2a56bb7e13bf8794e0f5605a3eae0cb66d7cd009",
  "author": "guptapriya",
  "created_at": "2019-06-05 16:11:16",
  "condition": [
   "label_shape=tf.TensorShape([length]),"
  ],
  "consequent": [
   "label_shape=tf.TensorShape([batch, length]),"
  ]
 },
 {
  "sha": "2a56bb7e13bf8794e0f5605a3eae0cb66d7cd009",
  "author": "guptapriya",
  "created_at": "2019-06-05 16:11:16",
  "condition": [
   "FLAGS.param_set = \"tiny\""
  ],
  "consequent": [
   "FLAGS.param_set = param_set = \"tiny\""
  ]
 },
 {
  "sha": "2a56bb7e13bf8794e0f5605a3eae0cb66d7cd009",
  "author": "guptapriya",
  "created_at": "2019-06-05 16:11:16",
  "condition": [
   "input_shape=tf.TensorShape([length]),"
  ],
  "consequent": [
   "input_shape=tf.TensorShape([batch, length]),"
  ]
 },
 {
  "sha": "2a56bb7e13bf8794e0f5605a3eae0cb66d7cd009",
  "author": "guptapriya",
  "created_at": "2019-06-05 16:11:16",
  "condition": [
   "dataset = model_helpers.generate_synthetic_data("
  ],
  "consequent": [
   "return model_helpers.generate_synthetic_data("
  ]
 },
 {
  "sha": "d967bfae3ecf59178b896bceb4d1fbc8b8be0fa2",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:41:23",
  "condition": [
   " def test_train_static_batch(self):",
   "   FLAGS.static_batch = True",
   "   t = tm.TransformerTask(FLAGS)",
   "   t.train()",
   " def test_train_1_gpu_with_dist_strat(self):",
   "   FLAGS.distribution_strategy = \"one_device\"",
   "   t = tm.TransformerTask(FLAGS)",
   "   t.train()",
   " def test_train_2_gpu(self):",
   "   FLAGS.distribution_strategy = \"mirrored\"",
   "   FLAGS.num_gpus = 2",
   "   t = tm.TransformerTask(FLAGS)",
   "   t.train()"
  ],
  "consequent": []
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "self.bleu_ref = os.path.join(temp_dir, \"bleu_ref\")"
  ],
  "consequent": [
   "self.bleu_ref = os.path.join(self.cur_log_dir, \"bleu_ref\")",
   "self.flags_file = os.path.join(self.cur_log_dir, \"flags\")"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "self.vocab_file = os.path.join(temp_dir, \"vocab\")"
  ],
  "consequent": [
   "self.vocab_file = os.path.join(self.cur_log_dir, \"vocab\")"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "os.makedirs(self.temp_dir)"
  ],
  "consequent": [
   "os.makedirs(self.cur_log_dir)"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "self._load_weights_if_possible(",
   "  model, tf.train.latest_checkpoint(self.flags_obj.model_dir))"
  ],
  "consequent": [
   "self._load_weights_if_possible(model, flags_obj.init_weight_path)"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [],
  "consequent": [
   "   # Test model dir.",
   "   self._assert_exists(self.cur_log_dir)",
   "   # Test saving models.",
   "   self._assert_exists(",
   "       os.path.join(self.cur_log_dir, \"saves-model-weights.hdf5\"))",
   "   self._assert_exists(os.path.join(self.cur_log_dir, \"saves-model.hdf5\"))",
   "   # Test callbacks:",
   "   # TensorBoard file.",
   "   self._assert_exists(os.path.join(self.cur_log_dir, \"logs\"))",
   "   # CSVLogger file.",
   "   self._assert_exists(os.path.join(self.cur_log_dir, \"result.csv\"))",
   "   # Checkpoint file.",
   "   filenames = os.listdir(self.cur_log_dir)",
   "   matched_weight_file = any([WEIGHT_PATTERN.match(f) for f in filenames])",
   "   self.assertTrue(matched_weight_file)"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "self.bleu_source = os.path.join(temp_dir, \"bleu_source\")"
  ],
  "consequent": [
   "self.bleu_source = os.path.join(self.cur_log_dir, \"bleu_source\")"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "FLAGS.model_dir = os.path.join(temp_dir, FIXED_TIMESTAMP)"
  ],
  "consequent": [
   "FLAGS.model_dir = temp_dir",
   "FLAGS.init_logdir_timestamp = FIXED_TIMESTAMP"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "FLAGS.steps_between_evals = 1"
  ],
  "consequent": [
   "FLAGS.steps_per_epoch = 1"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "self.model_dir = FLAGS.model_dir",
   "self.temp_dir = temp_dir"
  ],
  "consequent": [
   "FLAGS.init_weight_path = None",
   "self.cur_log_dir = os.path.join(temp_dir, FIXED_TIMESTAMP)"
  ]
 },
 {
  "sha": "3aee5697859b7ff47c5bbb5609842efdf43cd80b",
  "author": "guptapriya",
  "created_at": "2019-06-05 15:21:45",
  "condition": [
   "if not os.path.exists(self.temp_dir):"
  ],
  "consequent": [
   "if not os.path.exists(self.cur_log_dir):"
  ]
 },
 {
  "sha": "6cfa81a1ff52d5804ba9df6a766991dbb53eeb3c",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:39:20",
  "condition": [
   "for mean, fn in self.metric_mean_fns:"
  ],
  "consequent": [
   "# TODO(guptapriya): Remove this check when underlying issue to create",
   "# metrics with dist strat in cross replica context is fixed.",
   "if (tf.distribute.has_strategy() and",
   "    not tf.distribute.in_cross_replica_context()):",
   "  for mean, fn in self.metric_mean_fns:"
  ]
 },
 {
  "sha": "d01ac9765980ad9664811ac8afc82f07da5e20e4",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:26:50",
  "condition": [
   "# Target is 0.635, but some runs are below that level. Until we have"
  ],
  "consequent": [
   "# Target is 0.625, but some runs are below that level. Until we have"
  ]
 },
 {
  "sha": "d01ac9765980ad9664811ac8afc82f07da5e20e4",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:26:50",
  "condition": [
   "'min_value': 0.630,"
  ],
  "consequent": [
   "'min_value': 0.618,"
  ]
 },
 {
  "sha": "d01ac9765980ad9664811ac8afc82f07da5e20e4",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:26:50",
  "condition": [
   "'max_value': 0.640})"
  ],
  "consequent": [
   "'max_value': 0.635})"
  ]
 },
 {
  "sha": "99a34a6c487f1ba9f0f9c45ce6f874053a8fe48b",
  "author": "guptapriya",
  "created_at": "2019-06-06 04:31:34",
  "condition": [
   "FLAGS.model_dir = self._get_model_dir('benchmark_1_gpu_no_ds_sb')"
  ],
  "consequent": [
   "FLAGS.model_dir = self._get_model_dir(",
   "  'benchmark_1_gpu_no_dist_strat_static_batch')"
  ]
 },
 {
  "sha": "97c1e8984fe72402cb42ac96cedf65dd97e6e9ec",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:31:26",
  "condition": [
   "FLAGS.model_dir = self._get_model_dir('benchmark_1_gpu_no_dist_strat')"
  ],
  "consequent": [
   "FLAGS.model_dir = self._get_model_dir('benchmark_1_gpu')"
  ]
 },
 {
  "sha": "97c1e8984fe72402cb42ac96cedf65dd97e6e9ec",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:31:26",
  "condition": [
   "def benchmark_1_gpu_no_dist_strat(self):"
  ],
  "consequent": [
   "def benchmark_1_gpu(self):"
  ]
 },
 {
  "sha": "97c1e8984fe72402cb42ac96cedf65dd97e6e9ec",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:31:26",
  "condition": [
   "\"\"\"Benchmark 1 gpu without distribution strategy with static batch.\"\"\""
  ],
  "consequent": [
   "\"\"\"Benchmark 1 gpu.\"\"\""
  ]
 },
 {
  "sha": "97c1e8984fe72402cb42ac96cedf65dd97e6e9ec",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:31:26",
  "condition": [
   "\"\"\"Benchmark 8 gpu with static batch.\"\"\""
  ],
  "consequent": [
   "\"\"\"Benchmark 8 gpu.\"\"\""
  ]
 },
 {
  "sha": "97c1e8984fe72402cb42ac96cedf65dd97e6e9ec",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:31:26",
  "condition": [
   "def benchmark_1_gpu_no_dist_strat_static_batch(self):"
  ],
  "consequent": [
   "def benchmark_1_gpu_static_batch(self):"
  ]
 },
 {
  "sha": "97c1e8984fe72402cb42ac96cedf65dd97e6e9ec",
  "author": "guptapriya",
  "created_at": "2019-06-05 14:31:26",
  "condition": [
   "\"\"\"Benchmark 1 gpu without distribution strategy.\"\"\""
  ],
  "consequent": [
   "\"\"\"Benchmark 1 gpu.\"\"\""
  ]
 },
 {
  "sha": "080347bc9056fdb8f0a2236ccdb5bfef1cdf0cca",
  "author": "guptapriya",
  "created_at": "2019-06-05 13:28:40",
  "condition": [
   "loss_scale_factor = (batch_size *",
   "                     tf.distribute.get_strategy().num_replicas_in_sync)"
  ],
  "consequent": [
   "loss_scale_factor = batch_size * tf.distribute.get_strategy().num_replicas_in_sync"
  ]
 },
 {
  "sha": "dcd76d49cde67518b155f800aeedadce2a00c64a",
  "author": "guptapriya",
  "created_at": "2019-06-05 11:43:23",
  "condition": [
   "per_epoch_callback = IncrementEpochCallback(producer)",
   "callbacks = [per_epoch_callback, time_callback]"
  ],
  "consequent": [
   "callbacks = [time_callback]"
  ]
 },
 {
  "sha": "dbdf712e211ae71f47b9d56d901cf54273525e27",
  "author": "guptapriya",
  "created_at": "2019-06-05 11:29:37",
  "condition": [
   "callbacks = [time_callback]"
  ],
  "consequent": [
   "per_epoch_callback = IncrementEpochCallback(producer)",
   "callbacks = [per_epoch_callback, time_callback]"
  ]
 },
 {
  "sha": "5b81bb594c9a20b33b6e793edfd08a207d843ba0",
  "author": "guptapriya",
  "created_at": "2019-06-05 10:45:45",
  "condition": [
   "sample_weight=valid_pt_mask_input) * 1.0 / loss_scale_factor)"
  ],
  "consequent": [
   "sample_weight=valid_pt_mask_input) * 1.0 / batch_size)"
  ]
 },
 {
  "sha": "302fa7390def9c7b3a9449f4a4f102604d471c40",
  "author": "Ayush Dubey",
  "created_at": "2019-06-05 01:10:16",
  "condition": [
   "self._report_benchmark(stats, wall_time_sec)"
  ],
  "consequent": [
   "self._report_benchmark(stats,",
   "                       wall_time_sec)"
  ]
 },
 {
  "sha": "302fa7390def9c7b3a9449f4a4f102604d471c40",
  "author": "Ayush Dubey",
  "created_at": "2019-06-05 01:10:16",
  "condition": [
   "super(Resnet50EstimatorBenchmarkBase, self).__init__("
  ],
  "consequent": [
   "super(Resnet50EstimatorBenchmark, self).__init__("
  ]
 },
 {
  "sha": "302fa7390def9c7b3a9449f4a4f102604d471c40",
  "author": "Ayush Dubey",
  "created_at": "2019-06-05 01:10:16",
  "condition": [
   "class Resnet50EstimatorBenchmarkBase(EstimatorBenchmark):"
  ],
  "consequent": [
   "class Resnet50EstimatorBenchmark(EstimatorBenchmark):"
  ]
 },
 {
  "sha": "302fa7390def9c7b3a9449f4a4f102604d471c40",
  "author": "Ayush Dubey",
  "created_at": "2019-06-05 01:10:16",
  "condition": [
   "\"\"\"Base class for benchmarks for ResNet50 using Estimator.\"\"\""
  ],
  "consequent": [
   "\"\"\"Benchmarks for ResNet50 using Estimator.\"\"\""
  ]
 },
 {
  "sha": "e59ad48ff20b5d34606cab2d77288508afcc0ec3",
  "author": "guptapriya",
  "created_at": "2019-06-04 06:31:12",
  "condition": [
   "default_flags['train_epochs'] = 10"
  ],
  "consequent": [
   "default_flags['train_epochs'] = 8"
  ]
 },
 {
  "sha": "e59ad48ff20b5d34606cab2d77288508afcc0ec3",
  "author": "guptapriya",
  "created_at": "2019-06-04 06:31:12",
  "condition": [
   "epoch+1, train_loss)"
  ],
  "consequent": [
   "epoch+1, train_loss/num_train_steps)"
  ]
 },
 {
  "sha": "3d2a7e7fbd708303151837d17e29b2119644d4ff",
  "author": "guptapriya",
  "created_at": "2019-06-04 04:13:24",
  "condition": [
   "self.add_metric(self.metric(in_top_k, sample_weight=metric_weights))"
  ],
  "consequent": [
   "self.add_metric(self.metric(in_top_k, metric_weights))"
  ]
 },
 {
  "sha": "d0186041edf10ad9316dd11b1c59248fe14a3f17",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:23:28",
  "condition": [
   "params[\"match_mlperf\"])"
  ],
  "consequent": [
   "self.params[\"match_mlperf\"])"
  ]
 },
 {
  "sha": "d0186041edf10ad9316dd11b1c59248fe14a3f17",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:23:28",
  "condition": [
   "callbacks = [per_epoch_callback, time_callback]"
  ],
  "consequent": [
   "callbacks = [per_epoch_callback] #, time_callback]"
  ]
 },
 {
  "sha": "d0186041edf10ad9316dd11b1c59248fe14a3f17",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:23:28",
  "condition": [
   "verbose=2)"
  ],
  "consequent": [
   "verbose=1)"
  ]
 },
 {
  "sha": "d0186041edf10ad9316dd11b1c59248fe14a3f17",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:23:28",
  "condition": [
   "softmax_logits, features[rconst.DUPLICATE_MASK], params)"
  ],
  "consequent": [
   "logits, features[rconst.DUPLICATE_MASK], params)"
  ]
 },
 {
  "sha": "d0186041edf10ad9316dd11b1c59248fe14a3f17",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:23:28",
  "condition": [
   "stats = build_stats(train_loss, eval_results, time_callback)"
  ],
  "consequent": [
   "stats = build_stats(train_loss, eval_results, None) #, time_callback)"
  ]
 },
 {
  "sha": "d7aa51b4b6e20ded2056c20429cce3f2147591c1",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:08:32",
  "condition": [
   "inputs={"
  ],
  "consequent": [
   "inputs=["
  ]
 },
 {
  "sha": "d7aa51b4b6e20ded2056c20429cce3f2147591c1",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:08:32",
  "condition": [
   "movielens.USER_COLUMN: user_input,",
   "movielens.ITEM_COLUMN: item_input,",
   "rconst.VALID_POINT_MASK: valid_pt_mask_input,",
   "rconst.DUPLICATE_MASK: dup_mask_input,",
   "rconst.TRAIN_LABEL_KEY: label_input},"
  ],
  "consequent": [
   "user_input,",
   "item_input,",
   "valid_pt_mask_input,",
   "dup_mask_input,",
   "label_input],"
  ]
 },
 {
  "sha": "95220449ad172f7679de6d3b22f13489cf6476e1",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:07:22",
  "condition": [
   "in_top_k, metric_weights = metric_fn(logits, dup_mask, self.params)"
  ],
  "consequent": [
   "dup_mask = tf.cast(dup_mask, tf.float32)",
   "logits = tf.slice(logits, [0, 0, 1], [-1, -1, -1])",
   "in_top_k, _, metric_weights, _ = neumf_model.compute_top_k_and_ndcg(",
   "    logits,",
   "    dup_mask,",
   "    self.params[\"match_mlperf\"])",
   "metric_weights = tf.cast(metric_weights, tf.float32)"
  ]
 },
 {
  "sha": "95220449ad172f7679de6d3b22f13489cf6476e1",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:07:22",
  "condition": [
   "in_top_k, metric_weights = metric_fn("
  ],
  "consequent": [
   "logits = tf.slice(softmax_logits, [0, 0, 1], [-1, -1, -1])"
  ]
 },
 {
  "sha": "95220449ad172f7679de6d3b22f13489cf6476e1",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:07:22",
  "condition": [
   "return logits"
  ],
  "consequent": [
   "return inputs[0]"
  ]
 },
 {
  "sha": "95220449ad172f7679de6d3b22f13489cf6476e1",
  "author": "guptapriya",
  "created_at": "2019-06-03 14:07:22",
  "condition": [
   "logits, features[rconst.DUPLICATE_MASK], params)"
  ],
  "consequent": [
   "dup_mask = features[rconst.DUPLICATE_MASK]",
   "in_top_k, _, metric_weights, _ = neumf_model.compute_top_k_and_ndcg(",
   "    logits,",
   "    dup_mask,",
   "    params[\"match_mlperf\"])",
   "metric_weights = tf.cast(metric_weights, tf.float32)"
  ]
 },
 {
  "sha": "9511801a46d8d17d7716afd32d1832ab1a0a4782",
  "author": "guptapriya",
  "created_at": "2019-06-03 13:50:38",
  "condition": [
   "keras_model.compile(optimizer=optimizer)"
  ],
  "consequent": [
   "keras_model.compile(",
   "    optimizer=optimizer,",
   "    cloning=params[\"clone_model_in_keras_dist_strat\"])"
  ]
 },
 {
  "sha": "f0a8be5daf03c80a59b4acf087a832cd77e868d1",
  "author": "guptapriya",
  "created_at": "2019-06-03 13:09:59",
  "condition": [
   "softmax_logits = keras_model(features)"
  ],
  "consequent": [
   "softmax_logits = keras_model([features[movielens.USER_COLUMN],",
   "                              features[movielens.ITEM_COLUMN]])"
  ]
 },
 {
  "sha": "f0a8be5daf03c80a59b4acf087a832cd77e868d1",
  "author": "guptapriya",
  "created_at": "2019-06-03 13:09:59",
  "condition": [
   "stats = build_stats(train_loss, eval_results, None) #, time_callback)"
  ],
  "consequent": [
   "stats = build_stats(train_loss, eval_results, time_callback)"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "verbose=1)"
  ],
  "consequent": [
   "verbose=2)"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "def build(self, input_shape):",
   "  self.metric = tf.keras.metrics.Mean(name=rconst.HR_METRIC_NAME)"
  ],
  "consequent": [
   "def _get_metric_fn(params):",
   "  \"\"\"Get the metrix fn used by model compile.\"\"\"",
   "  batch_size = params[\"batch_size\"]"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "in_top_k, _, metric_weights, _ = neumf_model.compute_top_k_and_ndcg("
  ],
  "consequent": [
   "   # The dup mask should be obtained from input data, but we did not yet find",
   "   # a good way of getting it with keras, so we set it to zeros to neglect the",
   "   # repetition correction",
   "   dup_mask = tf.zeros([batch_size, 1])",
   "   _, _, in_top_k, _, _ = (",
   "       neumf_model.compute_eval_loss_and_metrics_helper("
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "def _get_train_and_eval_data(producer, params):"
  ],
  "consequent": [
   "    in_top_k = tf.cond(",
   "        is_training,",
   "        lambda: tf.zeros(shape=in_top_k.shape, dtype=in_top_k.dtype),",
   "        lambda: in_top_k)",
   "",
   "    return in_top_k",
   "",
   "  return metric_fn",
   "",
   "",
   "def _get_train_and_eval_data(producer, params):"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "inputs=[",
   "    user_input,",
   "    item_input,",
   "    valid_pt_mask_input,",
   "    dup_mask_input,",
   "    label_input],"
  ],
  "consequent": [
   "inputs=[user_input, item_input],"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "class MetricLayer(tf.keras.layers.Layer):",
   "  \"\"\"Custom layer of metrics for NCF model.\"\"\""
  ],
  "consequent": [
   "def _keras_loss(y_true, y_pred):",
   "  # Here we are using the exact same loss used by the estimator",
   "  loss = tf.keras.losses.sparse_categorical_crossentropy(",
   "      y_pred=y_pred,",
   "      y_true=tf.cast(y_true, tf.int32),",
   "      from_logits=True)",
   "  return loss"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "def call(self, inputs):",
   "  logits, dup_mask = inputs",
   "  dup_mask = tf.cast(dup_mask, tf.float32)"
  ],
  "consequent": [
   "def metric_fn(y_true, y_pred):",
   "  \"\"\"Returns the in_top_k metric.\"\"\"",
   "  softmax_logits = y_pred[0, :]"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "logits = tf.slice(logits, [0, 0, 1], [-1, -1, -1])"
  ],
  "consequent": [
   "logits = tf.slice(softmax_logits, [0, 1], [batch_size, 1])"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "dup_mask,"
  ],
  "consequent": [
   "dup_mask,",
   "params[\"num_neg\"],"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "logits,"
  ],
  "consequent": [
   "logits,",
   "softmax_logits,"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "callbacks = [per_epoch_callback] #, time_callback]"
  ],
  "consequent": [
   "callbacks = [per_epoch_callback, time_callback]"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "self.params[\"match_mlperf\"])"
  ],
  "consequent": [
   "params[\"match_mlperf\"],",
   "params[\"use_xla_for_gpu\"]))"
  ]
 },
 {
  "sha": "70704b9486e7e94ff31cac5c55720333844903bf",
  "author": "guptapriya",
  "created_at": "2019-06-03 11:54:51",
  "condition": [
   "labels = tf.cast(tf.zeros_like(features[movielens.USER_COLUMN]), tf.bool)"
  ],
  "consequent": [
   "if not params[\"keras_use_ctl\"]:",
   "  features.pop(rconst.DUPLICATE_MASK)",
   "labels = tf.zeros_like(features[movielens.USER_COLUMN])"
  ]
 },
 {
  "sha": "e7b21bfd58614f43131be55308dadd619d7773ae",
  "author": "Dwight J Lyle",
  "created_at": "2019-06-04 01:02:51",
  "condition": [
   "absl_app.run(main)"
  ],
  "consequent": [
   "absl_app.run()"
  ]
 },
 {
  "sha": "69e2e3f6cfff25e30beb35a455e24d7a1efc00e1",
  "author": "Toby Boyd",
  "created_at": "2019-06-04 01:02:21",
  "condition": [
   "\"\"\"Test Keras model with 8 GPUs, fp16, dynamic loss scaling, and tuned.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model with 8 GPUs, fp16, dynamic loss scaling, and manual",
   "   config tuning.",
   "\"\"\""
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "\"\"\"Test in legacy graph mode with manual config tuning, XLA, 8 GPUs, fp16."
  ],
  "consequent": [
   "\"\"\"Test Keras model in legacy graph mode with manual config tuning, XLA,"
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "\"\"\"Test in legacy graph mode with manual config tuning, XLA, 8 GPUs, fp16."
  ],
  "consequent": [
   "\"\"\"Test Keras model in legacy graph mode with manual config tuning, XLA,",
   "   8 GPUs and fp16."
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "   Delay performance measurement for stable performance on 96 vCPU platforms."
  ],
  "consequent": [
   "8 GPUs and fp16. Delay performance measurement for stable performance",
   "on 96 vCPU platforms."
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "\"\"\"Test with manual config tuning, XLA, 8 GPUs, fp16, and cloning."
  ],
  "consequent": [
   "\"\"\"Test Keras model with manual config tuning, XLA, 8 GPUs, fp16, and"
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "# TODO(xunkai): _batch_examples might need to do something special for"
  ],
  "consequent": [
   "# TODO: _batch_examples might need to do something special for num_replicas."
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "   Delay performance measurement for stable performance on 96 vCPU platforms."
  ],
  "consequent": [
   "performance measurement for stable performance on 96 vCPU platforms."
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "\"\"\"Test with manual config tuning, XLA, 8 GPUs and fp16."
  ],
  "consequent": [
   "\"\"\"Test Keras model with manual config tuning, XLA, 8 GPUs and fp16. Delay"
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "from absl import app as absl_app  # pylint: disable=unused-import"
  ],
  "consequent": [
   "from absl import app as absl_app"
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "\"\"\"Test with manual config tuning, XLA, 8 GPUs, fp16, and cloning.\"\"\""
  ],
  "consequent": [
   "\"\"\"Test Keras model with manual config tuning, XLA, 8 GPUs, fp16, and",
   "   cloning.",
   "\"\"\""
  ]
 },
 {
  "sha": "7546a9e3d1c51798bd20407ea1749e13b87b0368",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 05:52:08",
  "condition": [
   "   Delay performance measurement for stable performance on 96 vCPU platforms."
  ],
  "consequent": [
   "cloning. Delay performance measurement for stable performance on 96 vCPU",
   "platforms."
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "\"If False, then the experimental code path is used that does not \""
  ],
  "consequent": [
   "'If False, then the experimental code path is used that doesn\\'t '"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "# TODO(xunkai): investigate if removing code branching improves performance."
  ],
  "consequent": [
   "# TODO: investigate whether removing code branching improves performance."
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "\"If True, we stop the training when it reaches hr_threshold\"))"
  ],
  "consequent": [
   "'If True, we stop the training when it reaches hr_threshold'))"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   " Returns:"
  ],
  "consequent": [
   "Returns:"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "stats[\"train_finish_time\"] = time_callback.train_finish_time"
  ],
  "consequent": [
   "stats['train_finish_time'] = time_callback.train_finish_time"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "stats[\"avg_exp_per_second\"] = ("
  ],
  "consequent": [
   "stats['avg_exp_per_second'] = ("
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "FLAGS.max_length = 64"
  ],
  "consequent": [
   "FLAGS.max_length = 64    "
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "\"which is not available. Available metrics are: %s\","
  ],
  "consequent": [
   "'which is not available. Available metrics are: %s',"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "# TODO(guptapriya): Remove this check when underlying issue to create"
  ],
  "consequent": [
   "# TODO(guptapriya): Remove this check when underlying issue to create metrics"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "train_loss = train_history[\"loss\"][-1]"
  ],
  "consequent": [
   "train_loss = train_history['loss'][-1]"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "logging.info(\"Done training epoch %s, epoch loss=%s.\","
  ],
  "consequent": [
   "logging.info(\"Done training epoch {}, epoch loss={}.\".format("
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "logging.info(\"Done eval epoch %s, hr=%s.\", epoch+1, hr_sum/hr_count)"
  ],
  "consequent": [
   "logging.info(\"Done eval epoch {}, hr={}.\".format(epoch+1,",
   "                                                 hr_sum/hr_count))"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "params[\"max_length\"] = flags_obj.max_length or params[\"max_length\"]"
  ],
  "consequent": [
   "params[\"max_length\"] = flags_obj.max_length or params['max_length']"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "params[\"batch_size\"] = params[\"eval_batch_size\"]"
  ],
  "consequent": [
   "params['batch_size'] = params['eval_batch_size']"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "\"If True, we use a custom training loop for keras.\"))"
  ],
  "consequent": [
   "'If True, we use a custom training loop for keras.'))"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "logging.warning(\"Early stopping conditioned on metric `%s` \""
  ],
  "consequent": [
   "logging.warning('Early stopping conditioned on metric `%s` '"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "print(\"Epoch %05d: early stopping\" % (self.stopped_epoch + 1))"
  ],
  "consequent": [
   "print('Epoch %05d: early stopping' % (self.stopped_epoch + 1))"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "self.monitor, \",\".join(list(logs.keys())))"
  ],
  "consequent": [
   "self.monitor, ','.join(list(logs.keys())))"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "if params[\"keras_use_ctl\"] and int(tf.__version__.split(\".\")[0]) == 1:"
  ],
  "consequent": [
   "if params['keras_use_ctl'] and int(tf.__version__.split('.')[0]) == 1:"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "stats[\"step_timestamp_log\"] = timestamp_log"
  ],
  "consequent": [
   "stats['step_timestamp_log'] = timestamp_log"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "stats[\"eval_loss\"] = eval_result[0]"
  ],
  "consequent": [
   "stats['eval_loss'] = eval_result[0]"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "os.environ[\"TF_CONFIG\"] = json.dumps(tf_config_env)"
  ],
  "consequent": [
   "os.environ['TF_CONFIG'] = json.dumps(tf_config_env)"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "stats[\"eval_hit_rate\"] = eval_result[1]"
  ],
  "consequent": [
   "stats['eval_hit_rate'] = eval_result[1]"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "if (tf.distribute.has_strategy() and",
   "    not tf.distribute.in_cross_replica_context()):",
   "  for mean, fn in self.metric_mean_fns:"
  ],
  "consequent": [
   "for mean, fn in self.metric_mean_fns:"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "# metrics with dist strat in cross replica context is fixed."
  ],
  "consequent": [
   "# with dist strat in cross replica context is fixed.",
   "if tf.distribute.has_strategy() and not tf.distribute.in_cross_replica_context():"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "# TODO(guptapriya): Figure out a way to structure input that works in both"
  ],
  "consequent": [
   "# TODO(guptapriya): Figure out a way to structure input that works in both "
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "if params[\"keras_use_ctl\"]:"
  ],
  "consequent": [
   "if params['keras_use_ctl']:"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "eval_result: Output of the eval step. Assumes first value is eval_loss and"
  ],
  "consequent": [
   "eval_output: Output of the eval step. Assumes first value is eval_loss and"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "batch_size = params[\"batch_size\"]"
  ],
  "consequent": [
   "batch_size = params['batch_size']"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "epoch+1, train_loss/num_train_steps)"
  ],
  "consequent": [
   "epoch+1, train_loss/num_train_steps))"
  ]
 },
 {
  "sha": "ba4154144ca0efd38ac92ea41c4c6c3b6c231e8b",
  "author": "Haoyu Zhang",
  "created_at": "2019-06-01 04:47:17",
  "condition": [
   "stats[\"loss\"] = loss"
  ],
  "consequent": [
   "stats['loss'] = loss"
  ]
 },
 {
  "sha": "ab53cb74457e565dbdd543375ebfcae5e89c02bd",
  "author": "Goldie Gadde",
  "created_at": "2019-06-01 03:53:58",
  "condition": [
   "if hasattr(tf, 'contrib'):",
   "  return False",
   "else:",
   "  return True"
  ],
  "consequent": [
   "return tf.__version__.startswith('2')"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "# If TimeHistory is enabled, progress bar would be messy. Increase the",
   "# verbose level to get rid of it.",
   "verbose=(2 if flags_obj.enable_time_history else 1))"
  ],
  "consequent": [
   "verbose=2)"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "# First calculate batch size (token number) per worker, then divide it",
   "# into sentences, and finally expand to a global batch. It could prove",
   "# the global batch divisble for distribution strategy.",
   "((batch_size // num_replicas) // max_length) * num_replicas,",
   "([max_length], [max_length]), drop_remainder=True)"
  ],
  "consequent": [
   "batch_size // max_length, ([max_length], [max_length]),",
   "drop_remainder=True)"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "static_batch=False, num_replicas=1):"
  ],
  "consequent": [
   "static_batch=False):"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "batch_size: Maximum number of tokens per global batch of examples."
  ],
  "consequent": [
   "batch_size: Maximum number of tokens per batch of examples"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "static_batch=params[\"static_batch\"], num_replicas=params[\"num_gpus\"])"
  ],
  "consequent": [
   "static_batch=params[\"static_batch\"])"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "num_parallel_calls=tf.data.experimental.AUTOTUNE).with_options(options)"
  ],
  "consequent": [
   "num_parallel_calls=num_parallel_calls)"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "if FLAGS.enable_time_history:",
   "  time_callback = keras_utils.TimeHistory(FLAGS.batch_size, FLAGS.log_steps)"
  ],
  "consequent": [
   "time_callback = keras_utils.TimeHistory(FLAGS.batch_size, FLAGS.log_steps)"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "name='static_batch', short_name='sb', default=False,"
  ],
  "consequent": [
   "name='static_batch', default=False,"
  ]
 },
 {
  "sha": "ab1c1dfc79ea97918250bcf8cbfbe94fde6bea7f",
  "author": "Zhang Xunkai",
  "created_at": "2019-05-29 16:22:11",
  "condition": [
   "repeat=params[\"repeat_dataset\"], static_batch=params[\"static_batch\"],"
  ],
  "consequent": [
   "repeat=params[\"repeat_dataset\"], static_batch=params[\"static_batch\"])"
  ]
 },
 {
  "sha": "e80b385a20bee6a21af1683424575bea7c8457bc",
  "author": "guptapriya",
  "created_at": "2019-05-29 09:14:55",
  "condition": [
   "FLAGS.max_length = 64"
  ],
  "consequent": [
   "FLAGS.max_length = 40"
  ]
 },
 {
  "sha": "3bb5dd6c0cba94ee6c81c35e225b0e1df7246436",
  "author": "guptapriya",
  "created_at": "2019-05-29 14:33:59",
  "condition": [
   "FLAGS.num_gpus = 8"
  ],
  "consequent": [
   "FLAGS.num_gpus = 1"
  ]
 },
 {
  "sha": "b5a698190b5aef6e29f6304765e968bbb7c90302",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 10:00:43",
  "condition": [
   "\"keras_use_ctl\": flags_obj.keras_use_ctl,"
  ],
  "consequent": [
   "\"tensorflow_v2\": int(tf.__version__.split('.')[0]) > 1,"
  ]
 },
 {
  "sha": "b5a698190b5aef6e29f6304765e968bbb7c90302",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 10:00:43",
  "condition": [
   "if params['keras_use_ctl']:"
  ],
  "consequent": [
   "if params['tensorflow_v2']:"
  ]
 },
 {
  "sha": "b5a698190b5aef6e29f6304765e968bbb7c90302",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 10:00:43",
  "condition": [
   "if not params[\"keras_use_ctl\"]:"
  ],
  "consequent": [
   "if not params[\"tensorflow_v2\"]:"
  ]
 },
 {
  "sha": "3928d48174d928d5fdd1599d262e200480699adb",
  "author": "Igor",
  "created_at": "2019-05-29 07:22:52",
  "condition": [
   "FLAGS.distribution_strategy = 'off'"
  ],
  "consequent": [
   "FLAGS.distribution_strategy = off"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "name=\"hr_threshold\", default=1.0,"
  ],
  "consequent": [
   "name=\"hr_threshold\", default=None,"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "   if history and history.history:",
   "     train_history = history.history",
   "     train_loss = train_history['loss'][-1]",
   " stats = build_stats(train_loss, eval_results, time_callback)"
  ],
  "consequent": [
   "stats = build_stats(history, eval_results, time_callback)"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   " if params['tensorflow_v2']:",
   "   loss_object = tf.losses.SparseCategoricalCrossentropy(",
   "       reduction=tf.keras.losses.Reduction.SUM,",
   "       from_logits=True)",
   "   train_input_iterator = strategy.make_dataset_iterator(train_input_dataset)",
   "   eval_input_iterator = strategy.make_dataset_iterator(eval_input_dataset)",
   "   @tf.function",
   "   def train_step():",
   "     \"\"\"Called once per step to train the model.\"\"\"",
   "     def step_fn(inputs):",
   "       \"\"\"Computes loss and applied gradient per replica.\"\"\"",
   "       features, labels = inputs",
   "       with tf.GradientTape() as tape:",
   "         softmax_logits = keras_model([features[movielens.USER_COLUMN],",
   "                                       features[movielens.ITEM_COLUMN]])",
   "         loss = loss_object(labels, softmax_logits,",
   "                            sample_weight=features[rconst.VALID_POINT_MASK])",
   "         loss *= (1.0 / (batch_size*strategy.num_replicas_in_sync))",
   "       grads = tape.gradient(loss, keras_model.trainable_variables)",
   "       optimizer.apply_gradients(list(zip(grads,",
   "                                          keras_model.trainable_variables)))",
   "       return loss",
   "     per_replica_losses = strategy.experimental_run(step_fn,",
   "                                                    train_input_iterator)",
   "     mean_loss = strategy.reduce(",
   "         tf.distribute.ReduceOp.SUM, per_replica_losses, axis=None)",
   "     return mean_loss",
   "   @tf.function",
   "   def eval_step():",
   "     \"\"\"Called once per eval step to compute eval metrics.\"\"\"",
   "     def step_fn(inputs):",
   "       \"\"\"Computes eval metrics per replica.\"\"\"",
   "       features, _ = inputs",
   "       softmax_logits = keras_model([features[movielens.USER_COLUMN],",
   "                                     features[movielens.ITEM_COLUMN]])",
   "       logits = tf.slice(softmax_logits, [0, 0, 1], [-1, -1, -1])",
   "       dup_mask = features[rconst.DUPLICATE_MASK]",
   "       in_top_k, _, metric_weights, _ = neumf_model.compute_top_k_and_ndcg(",
   "           logits,",
   "           dup_mask,",
   "           params[\"match_mlperf\"])",
   "       metric_weights = tf.cast(metric_weights, tf.float32)",
   "       hr_sum = tf.reduce_sum(in_top_k*metric_weights)",
   "       hr_count = tf.reduce_sum(metric_weights)",
   "       return hr_sum, hr_count",
   "     per_replica_hr_sum, per_replica_hr_count = (",
   "         strategy.experimental_run(step_fn, eval_input_iterator))",
   "     hr_sum = strategy.reduce(",
   "         tf.distribute.ReduceOp.SUM, per_replica_hr_sum, axis=None)",
   "     hr_count = strategy.reduce(",
   "         tf.distribute.ReduceOp.SUM, per_replica_hr_count, axis=None)",
   "     return hr_sum, hr_count",
   "   time_callback.on_train_begin()",
   "   for epoch in range(FLAGS.train_epochs):",
   "     per_epoch_callback.on_epoch_begin(epoch)",
   "     train_input_iterator.initialize()",
   "     train_loss = 0",
   "     for step in range(num_train_steps):",
   "       time_callback.on_batch_begin(step+epoch*num_train_steps)",
   "       train_loss += train_step()",
   "       time_callback.on_batch_end(step+epoch*num_train_steps)",
   "     logging.info(\"Done training epoch {}, epoch loss={}.\".format(",
   "         epoch+1, train_loss/num_train_steps))",
   "     eval_input_iterator.initialize()",
   "     hr_sum = 0",
   "     hr_count = 0",
   "     for _ in range(num_eval_steps):",
   "       step_hr_sum, step_hr_count = eval_step()",
   "       hr_sum += step_hr_sum",
   "       hr_count += step_hr_count",
   "     logging.info(\"Done eval epoch {}, hr={}.\".format(epoch+1,",
   "                                                      hr_sum/hr_count))",
   "     if (FLAGS.early_stopping and",
   "         float(hr_sum/hr_count) > params[\"hr_threshold\"]):",
   "       break",
   "   time_callback.on_train_end()",
   "   eval_results = [None, hr_sum/hr_count]",
   " else:",
   "   with distribution_utils.get_strategy_scope(strategy):",
   "     keras_model.compile("
  ],
  "consequent": [
   "keras_model.compile("
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "- Distributed training with keras fit does not support extra inputs. The"
  ],
  "consequent": [
   "- Distributed training does not support extra inputs. The current"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "if loss:",
   "  stats['loss'] = loss"
  ],
  "consequent": [
   "if history and history.history:",
   "  train_history = history.history",
   "  stats['loss'] = train_history['loss'][-1]"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "if not params[\"tensorflow_v2\"]:",
   "  features.pop(rconst.DUPLICATE_MASK)"
  ],
  "consequent": [
   "features.pop(rconst.DUPLICATE_MASK)"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "# eval). This carries over that rounding to batch_size as well. This is the"
  ],
  "consequent": [
   "# eval). This carries over that rounding to batch_size as well."
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "per_epoch_callback = IncrementEpochCallback(producer)",
   "callbacks = [per_epoch_callback, time_callback]"
  ],
  "consequent": [
   "callbacks = [",
   "    IncrementEpochCallback(producer), time_callback]"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "if not params[\"tensorflow_v2\"]:",
   "  train_input_dataset = train_input_dataset.repeat(FLAGS.train_epochs)"
  ],
  "consequent": [
   "train_input_dataset = train_input_dataset.repeat(FLAGS.train_epochs)"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "loss: The final loss at training time."
  ],
  "consequent": [
   "history: Results of the training step. Supports both categorical_accuracy",
   "  and sparse_categorical_accuracy."
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "def build_stats(loss, eval_result, time_callback):"
  ],
  "consequent": [
   "def build_stats(history, eval_result, time_callback):"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "current implementation for fit does not use the DUPLICATE_MASK in the"
  ],
  "consequent": [
   "implementation does not use the DUPLICATE_MASK in the input, which makes",
   "it extra, so it needs to be removed."
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "duplicate_mask_by_user = tf.cast("
  ],
  "consequent": [
   "duplicate_mask_by_user = tf.reshape(duplicate_mask,",
   "                                    (-1, rconst.NUM_EVAL_NEGATIVES + 1))"
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "current implementation for fit does not use the VALID_POINT_MASK in the"
  ],
  "consequent": [
   "implementation does not use the VALID_POINT_MASK in the input, which makes",
   "it extra, so it needs to be removed."
  ]
 },
 {
  "sha": "4c1d95cc63d73a1117628dd4d5016cb8d2f9f44d",
  "author": "Bruce Fontaine",
  "created_at": "2019-05-29 06:57:34",
  "condition": [
   "if not params[\"tensorflow_v2\"]:",
   "  features.pop(rconst.VALID_POINT_MASK)"
  ],
  "consequent": [
   "features.pop(rconst.VALID_POINT_MASK)"
  ]
 }
]